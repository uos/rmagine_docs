{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#rmagine","title":"Rmagine","text":"<p>Rmagine allows a robot to simulate sensor data for arbitrary range sensors directly on board via raytracing. Since robots typically only have limited computational resources, Rmagine aims at being flexible and lightweight, while scaling well even to large environment maps. It runs on several platforms like Laptops or embedded computing boards like Nvidia Jetson by putting an unified API over specific proprietary libraries provided by the hardware manufacturers. This work is designed to support the future development of robotic applications depending on simulation of range data that could previously not be computed in reasonable time on mobile systems.</p>"},{"location":"#design-goals","title":"Design Goals","text":"<p>Rmagine is mainly designed for robotic applications:</p> <ul> <li>Perform multiple sensor simulations simultaneously and in realtime.</li> <li>Compute the same operations on different computing devices (CPU, GPU..).</li> <li>Hold data at device of computation to minimize copy overhead between devices.</li> <li>Maintain minimal graphical overhead (offscreen-rendering)</li> <li>Support runtime critical operations, e.g. Monte Carlo simulations</li> </ul>"},{"location":"#intersection-attributes","title":"Intersection Attributes","text":"<p>Rmagine supports to select certain attributes that shall be computed and returned at a ray-surface intersection. The following image shows the simulating a spherical sensor model and selecting Cartesian points (<code>rm::Points</code>), surface normals (<code>rm::Normals</code>), object ids (<code>rm::ObjectIds</code>) as attributes.</p> <p></p> <p>The points and normals are represented by a fixed length line segment with the Cartesian point as origin the surface normal as direction, colored by the object id.</p> <p>Read more details about this here: Getting Started/Simulation.</p>"},{"location":"#citation","title":"Citation","text":"<p>We presented this work at ICRA'23 in London. The paper gives valuable insights of the design concepts of this library. When using the Rmagine library or any related ideas in your scientific work, please reference the following paper:</p> <pre><code>@inproceedings{mock2023rmagine,\n  title={{Rmagine: 3D Range Sensor Simulation in Polygonal Maps via Ray Tracing for Embedded Hardware on Mobile Robots}}, \n  author={Mock, Alexander and Wiemann, Thomas and Hertzberg, Joachim},\n  booktitle={IEEE International Conference on Robotics and Automation (ICRA)}, \n  year={2023},\n  doi={10.1109/ICRA48891.2023.10161388}\n}\n</code></pre>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<p>This documentation cosists of several examples, guides and conceptual explanations to give users a more thourough understanding of Rmagine. As the name tells, new users should make themselfs familar with Getting Started first, before continuing to the more advanced examples.</p> <p>Rmagine</p> <ul> <li>Overview</li> <li>Installation</li> <li>Integration</li> </ul> <p>Getting Started</p> <ul> <li>Maps</li> <li>Sensors</li> <li>Simulation</li> <li>Problem Modelling</li> <li>Noise</li> </ul> <p>Library</p> <ul> <li>Concepts</li> <li>Math</li> <li>Memory</li> <li>Maps</li> </ul> <p>Extra</p> <ul> <li>Tools</li> <li>Data</li> <li>Embree 3</li> <li>CMake - Advanced</li> <li>Contributions</li> <li>News</li> </ul>"},{"location":"#contributions","title":"Contributions","text":"<p>You are welcome to contribute to the docs of Rmagine! Thorough and clear documentation is essential. You can help us by correcting mistakes, improving content, or adding examples that facilitate user navigation and usage of the project. Please submit any documentation-related issues to the repository rmagine_docs. If you're making fixes or adding examples, don\u2019t hesitate to submit a pull request afterward!</p>"},{"location":"#pr-workflow","title":"PR workflow","text":"<p>How to contribute to this documentation via pull requests:</p> <ol> <li>Fork the repository: rmagine_docs.</li> <li>Make changes on your forked repository.</li> <li>Check locally on your machine if mkdocs is able to compile your changes (instructions).</li> <li>Go to Github and click \"Pull Request\", select this repository's \"main\" branch as target.</li> <li>If you added new content, please provide a brief explanation of why you believe it is beneficial for the documentation.</li> <li>Send PR</li> </ol>"},{"location":"installation/","title":"Installation (From Source)","text":"<p>The following instructions are tested on an Ubuntu 20.04 operating system.</p>"},{"location":"installation/#dependencies","title":"Dependencies","text":""},{"location":"installation/#assimp-open-assets-importer-library","title":"Assimp (Open Assets Importer Library)","text":"<p>For loading commonly used mesh/scene formats.</p> <pre><code>user@pc:~$ sudo apt install libassimp-dev\n</code></pre>"},{"location":"installation/#backbones","title":"Backbones","text":"<p>Rmagine provides an interface to integrate ray tracing libraries, we call backbones. All of these backbones are optional. So far we integrated Intel Embree and NVIDIA OptiX.</p>"},{"location":"installation/#embree-backbone-optional","title":"Embree Backbone (optional)","text":"<p>We support Embree in its latest version (tested: v4.0.1, v4.2.0):</p> <pre><code>user@pc:~$ git clone https://github.com/embree/embree.git\nuser@pc:~$ mkdir embree/build &amp;&amp; cd embree/build\nuser@pc:~/embree/build$ cmake -DCMAKE_BUILD_TYPE=Release ..\nuser@pc:~/embree/build$ make -j`nproc`\nuser@pc:~/embree/build$ sudo make install\n</code></pre> <p>For older Embree versions we refer to this.</p>"},{"location":"installation/#optix-backbone-optional","title":"OptiX Backbone (optional)","text":"<p>Rmagine supports NVIDIA OptiX versions of 7.2 or newer (experimental support for OptiX 8). The OptiX-Library is installed via the GPU driver. The OptiX-Headers can be downloaded here. The Headers require a specific GPU driver and CUDA version to be installed on your system:</p> OptiX Version Minimum Driver Version 7.2 456.71 7.3 465.84 7.4 495.89 7.5 495.89 (untested) 7.6 520.00 (untested) 7.7 530.41"},{"location":"installation/#compilation","title":"Compilation","text":"<p>Download the Rmagine repository. </p> <pre><code>user@pc:~/rmagine$ mkdir build\nuser@pc:~/rmagine$ cd build\nuser@pc:~/rmagine/build$ cmake ..\nuser@pc:~/rmagine/build$ make\n</code></pre> <p>The path to OptiX-Headers should be specified with the CMake-Variable <code>OptiX_INCLUDE_DIR</code>. This can be done using ccmake, for example.</p>"},{"location":"installation/#bash-variable-alternative","title":"Bash Variable (Alternative)","text":"<p>Alternatively, cmake checks for the environment variable <code>OPTIX_INCLUDE_DIR</code> to exist. After downloading the OptiX-SDK you can add the following command to your <code>.bashrc</code>:</p> <pre><code>export OPTIX_INCLUDE_DIR=~/.../NVIDIA-OptiX-SDK-7.4.0-linux64-x86_64/include\n</code></pre> <p>After adding this path, the project should compile without changing the cmake flags.</p>"},{"location":"installation/#optional-check-compilation","title":"Optional: Check Compilation","text":"<p>You can check if everything went wrong by running the benchmark that was build besides the library:</p> <pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_benchmark_cpu ../dat/sphere.ply\n...\n[ 100% - velos/s: 6261.9, mean: 6244.84] \nResult: 6244.84 velos/s\n</code></pre> <p>or if the OptiX support was successfully build:</p> <pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_benchmark_gpu ../dat/sphere.ply\n...\n[ 100% - velos/s: 383094, mean: 383457, rays/s: 5.52178e+09] \nResult: 383457 velos/s\n</code></pre>"},{"location":"installation/#installation","title":"Installation","text":"<p>After compilation do</p> <pre><code>user@pc:~/rmagine/build$ sudo make install\n</code></pre>"},{"location":"installation/#optional-check-installation","title":"Optional: Check Installation","text":"<p>You can check if everything went wrong by running the benchmark that was build besides the library:</p> <pre><code>user@pc:~$ rmagine_benchmark_cpu rmagine/dat/sphere.ply\n...\n[ 100% - velos/s: 6261.9, mean: 6244.84] \nResult: 6244.84 velos/s\n</code></pre> <p>or if the OptiX support was successfully build:</p> <pre><code>user@pc:~$ rmagine_benchmark_gpu rmagine/dat/sphere.ply\n...\n[ 100% - velos/s: 383094, mean: 383457, rays/s: 5.52178e+09] \nResult: 383457 velos/s\n</code></pre>"},{"location":"installation/#uninstall-rmagine","title":"Uninstall Rmagine","text":"<pre><code>user@pc:~/rmagine/build$ sudo make uninstall\n</code></pre>"},{"location":"installation/#installation-debian-package-experimental","title":"Installation (Debian Package) - Experimental","text":"<p>We are working on creating debian packages for easier installations.</p>"},{"location":"installation/#dependencies_1","title":"Dependencies","text":"<pre><code>$ sudo apt install libassimp-dev libeigen3-dev\n</code></pre>"},{"location":"installation/#install","title":"Install","text":"<p>Download latest Rmagine debian packages from Github releases page (v2.2.2). Install the core by calling</p> <pre><code>sudo apt install ./rmagine-core_2.2.2_amd64.deb\n</code></pre>"},{"location":"installation/#embree-backbone","title":"Embree Backbone","text":"<p>We support Embree in its latest version (tested: v4.0.1 - v4.3.0). Make sure you have Embree installed on your system.</p> <pre><code>sudo apt install ./rmagine-embree_2.2.2_amd64.deb\n</code></pre>"},{"location":"installation/#optix-backbone","title":"OptiX Backbone","text":"<p>Make sure you have a current NVIDIA driver installed, then install rmagine-cuda and rmagine-optix by:</p> <pre><code>sudo apt install ./rmagine-cuda_2.2.2_amd64.deb\nsudo apt install ./rmagine-optix_2.2.2_amd64.deb\n</code></pre>"},{"location":"installation/#uninstall","title":"Uninstall","text":"<p>To uninstall everything related to rmagine, call:</p> <pre><code>sudo apt-get remove rmagine-core\n</code></pre>"},{"location":"integration/","title":"Integration","text":"<p>How to use and integrate Rmagine into your own project.</p>"},{"location":"integration/#cpu-embree","title":"CPU (Embree)","text":""},{"location":"integration/#in-code","title":"In Code","text":"<pre><code>#include &lt;rmagine/map/EmbreeMap.hpp&gt;\n#include &lt;rmagine/simulation/SphereSimulatorEmbree.hpp&gt;\n\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    std::string filename = \"path/to/mesh/file\";\n    rm::EmbreeMapPtr map = rm::import_embree_map(filename);\n\n    rm::SphereSimulatorEmbree sim;\n    sim.setMap(map);\n\n    // go on (see workflow section)\n    return 0;\n}\n</code></pre>"},{"location":"integration/#cmake","title":"CMake","text":"<p>Add to your CMakeLists.txt:</p> <pre><code>add_compile_options(-std=c++17)\nset(CMAKE_CXX_STANDARD 17)\n\n# find components of a specific rmagine version\n# '2.2.8' will get the newest rmagine which \n# is greater equal 2.2.8\nfind_package(rmagine 2.2.8\n  COMPONENTS\n    core \n    embree\n)\n\nadd_executable(my_rmagine_app \n    src/my_rmagine_app.cpp)\n\n# link against rmagine targets\ntarget_link_libraries(my_rmagine_app\n    rmagine::core\n    rmagine::embree\n)\n</code></pre>"},{"location":"integration/#gpu-optix","title":"GPU (OptiX)","text":""},{"location":"integration/#in-code_1","title":"In Code","text":"<pre><code>#include &lt;rmagine/map/OptixMap.hpp&gt;\n#include &lt;rmagine/simulation/SphereSimulatorOptix.hpp&gt;\n\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    std::string filename = \"path/to/mesh/file\";\n    rm::OptixMapPtr map = rm::import_optix_map(filename);\n\n    rm::SphereSimulatorOptix sim;\n    sim.setMap(map);\n\n    // go on (see workflow section)\n    return 0;\n}\n</code></pre>"},{"location":"integration/#cmake_1","title":"CMake","text":"<p>Add to your CMakeFile:</p> <pre><code>add_compile_options(-std=c++17)\nset(CMAKE_CXX_STANDARD 17)\n\n# find components of a specific rmagine version\n# '2.2.8' will get the newest rmagine which \n# is greater equal 2.2.8\nfind_package(rmagine 2.2.8 \n  COMPONENTS\n    core \n    cuda\n    optix\n)\n\nadd_executable(my_rmagine_app \n    src/my_rmagine_app.cpp)\n\n# link against rmagine targets\ntarget_link_libraries(my_rmagine_app\n    rmagine::core\n    rmagine::cuda\n    rmagine::optix\n)\n</code></pre> <p>For more details and alternate ways of integrating Rmagine into your CMake project we refer to: CMake - Advanced.</p>"},{"location":"extra/blender/","title":"Work with Blender","text":"<p>Blender is a powerful tool to create and modify existing maps for rmagine.</p> <p>Some Links to look up: - Webpage: https://www.blender.org/ - Docs: https://docs.blender.org/manual/en/latest/</p>"},{"location":"extra/blender/#useful-commands","title":"Useful commands","text":""},{"location":"extra/blender/#object-mode","title":"Object Mode","text":"Command Effect C Ctrl + G Move Object after: type X and \"0.5\" to move the object 0.5 along the X axis Ctrl + R Rotate Object after: type Z and \"45\" to rotate the object 45 degree around the X axis Ctrl + S Scale Object after: type X and \"2.0\" to scale the object 2.0 along the X axis"},{"location":"extra/blender/#collada-dae-exports-odyssey-of-wrong-imports","title":"Collada (DAE) exports (odyssey of wrong imports)","text":""},{"location":"extra/blender/#update","title":"UPDATE","text":"<p>Blender plugin does everything right, Assimp writes the wrong transformation: See last sentence.</p>"},{"location":"extra/blender/#beginning","title":"Beginning","text":"<p>Some strange errors happened while exporting blender's scene to collada format. I did the following in Blender (3.2.1):</p> <ul> <li>Moved the Cube 5 units along the x axis</li> <li>Moved the Cube 2 units along the y axis</li> <li>Moved the Cube 3 units along the z axis</li> <li>Rotated the Cube 45 degrees around the z axis</li> <li>Scaled the Cube with 0.2 (the resulting cube has the dimensions 0.4 x 0.4 x 0.4)</li> <li>Export DAE with default settings to \"~/utitled.dae\"</li> </ul> <p>After some library fixes to read the scene graph completely, any collada file generated by Blender no longer loads correctly.  With PLY exports, everything works as before.  So I inspected the generated outputs of the Blender Collada exports (read by Assimp):</p> <pre><code>$:~ ./bin/rmagine_map_info ~/untitled.dae\n#...\nScene Graph: \n- name: Scene\n- transform: \n  M4x4[\n    1 0 0 0\n    0 0 1 0\n    0 -1 0 0\n    0 0 0 1\n  ]\n- meshes: 0\n- children: 3\n#...\n  Node 2\n    - name: Cube\n    - transform: \n      M4x4[\n        0.141421 -0.141421 0 5\n        0.141421 0.141421 0 2\n        0 0 0.2 3\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 0\n    - children: 0\n</code></pre> <p>And exactly there is the problem. I guess the \"Cube\" transformation is correct since it come from Blender directly.  The problem comes from the global matrix at node named \"Scene\". This matrix switches the y and z axes and negates the z axis (old y axis) afterwards. The complete transform of the \"Cube\" following the transformations to the root is</p> <p><code>v[5,3,-2], E[-1.5708, 0.785398, -1.26441e-07] with scale v[0.2,0.2,0.2]</code></p> <p>as expected, the total transform holds the axis-switched version of our previously done operations. But that is not what we want. Moving something in Blender along the x axis should result in an export with something in it that was moved along the x axis and no other axis. So how to fix it?  Pushing <code>Export -&gt; Colloda</code> opens a menu. Push the settings button in the top left corner. It opens a side panel, holding some values to change for the export. My first intuitive choice to set the forward axis to X and the up axis to Z were wrong, incomprehensibly. However, by trial and error I came up with setting these values as follows:</p> <pre><code>Forward Axis: Z\nUp Axis: -Y\n</code></pre> <p>With these settings the scene is exported exactly as I modelled it. Nevertheless, Blender exports the weird axis flip matrix at scene root. Every other transformation is adjusted such that every total transformation are valid.</p> <p><code>v[5,2,3], E[0, 0, 0.785398] with scale v[0.2,0.2,0.2]</code></p>"},{"location":"extra/blender/#not-yet-fixed","title":"Not yet fixed","text":"<p>Importing this exported file into Blender results in a different scene. It seems the Blender Collada Importer ignores the top level axis-switch matrix somehow? FBX export and import is correct using the axis switch by choice.</p>"},{"location":"extra/blender/#fixed","title":"FIXED","text":"<p>The wrong up most transformation is written by Assimp! </p> <ul> <li>Assimp::Importer io; io.SetPropertyBool(AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION, true) </li> </ul> <p>Capsuled in <code>AssimpIO</code>-Object (\"rmagine/map/AssimpIO.hpp\").</p> <p>The following code snipped already corrects the wrong transformation imports.</p> <pre><code>rm::AssimpIO io; \nconst aiScene* scene = io.ReadFile(\"file.dae\", 0);  \n</code></pre> <p>With that, it is possible to default export Collada files with Blender, import them with rmagine and import them in Blender again, without any errors.</p>"},{"location":"extra/blender/#filmbox-fbx-exports","title":"Filmbox (FBX) exports","text":"<p>Same problems as in DAE section. Set axis to:</p> <pre><code>Scale: 0.01\nForward: Y Forward\nUp: Z Up\n</code></pre> <p>Then everything is exported as modelled. Imports into Blender again are working as well. Luckilly, the global scene transform is set to identity here. Maybe that is why the Import is working again: ignoring the scene transform is not important if its an identity transform.</p> <p>TODO: check if Gazebo importer ignores the scene transform</p>"},{"location":"extra/blender/#building-a-3d-map-from-2d-building-plan","title":"Building a 3D map from 2D building plan","text":"<p>Using Blender Version 3.3.1</p>"},{"location":"extra/blender/#setting-up-a-2d-map-as-reference-image","title":"Setting up a 2D Map as Reference image","text":"<p>Make sure to be in Object Mode</p> <ol> <li>Click top right on the z-axis to make the view orthograhic top down</li> <li>In Scene press Shift+A to open the Add Panel. Then select your Image and Load it into scene. The Image should now be located on your xy-plane</li> <li>Scale the Image to a size where you think you can work good with. The exact scale can be determined later.</li> <li>Enable Opacity of Image: Select Image and go to \"Object Data Properties\" (bottom right). Checkmark the Opacity Button</li> </ol>"},{"location":"extra/blender/#modelling","title":"Modelling","text":"<p>To place single vertices in the scene we first have to enable an Add-On under <code>Edit -&gt; Preferences</code> called <code>Add Mesh: Extra Objects</code>. Then with Shift+A under the entry <code>Mesh</code> the option <code>Single Vert</code> should be available. Selecting <code>Single Vert</code> will place a single vertex in the origin and change to <code>Edit Mode</code>. A object should appear in the <code>Scene Collection</code> panel top right called <code>Vert</code>.</p> <ol> <li>Move the image so that the first vertex to set is in the origin</li> <li>Insert a single vertex. A new object should be created. The first vertex is placed in the Origin.</li> <li>Press <code>E</code> to extrude a vertex than click an endpoint to place the second vertex with an edge connecting both.</li> <li>Contour: By again pressing <code>E</code> you can create a path of vertices. I recommend to make a complete path along the contour of the building plan (without doors. Only walls).</li> <li>Walls: Once you have created a contour of edges go to <code>Edge Select</code>-Mode select everything. Press <code>E</code>and then <code>Z</code> to extrude the edges along the z-axis. Pull the walls to a arbitrary height (The exact scale is determined later).</li> <li>Ground Faces: Go to <code>Vertex Select</code>-Mode and select three ground Vertices you want to connect (Hold Shift). Press <code>F</code> to connect them to a Face.<ul> <li>If Faces are getting to long: Cut Wall-Face in two by selecting in in <code>Face Select</code> Mode and then pressing Ctrl+R</li> <li>Enable Statistics in Drop-Down Menu \"Overlays\" top right. If you notice during editing that there is more than one Vertex at one point: Select both of them in <code>Vertex Select</code>-Mode. The Right-Click and <code>Merge Vertices - Collapse</code>.</li> </ul> </li> </ol>"},{"location":"extra/cmake_advanced/","title":"CMake - Advanced","text":""},{"location":"extra/cmake_advanced/#cmake-standard","title":"CMake - Standard","text":"<p>The standard way of including Rmagine is by first installing it and then importing it to another project via CMake's <code>find_package</code> command as follows:</p> <pre><code>add_compile_options(-std=c++17)\nset(CMAKE_CXX_STANDARD 17)\n\n# find components of a specific rmagine version\n# '2.2.8' will get the newest rmagine which \n# is greater equal 2.2.8\nfind_package(rmagine 2.2.8\n  COMPONENTS\n    core \n    embree\n)\n\nadd_executable(my_rmagine_app \n    src/my_rmagine_app.cpp)\n\n# link against rmagine targets\ntarget_link_libraries(my_rmagine_app\n    rmagine::core\n    rmagine::embree\n)\n</code></pre>"},{"location":"extra/cmake_advanced/#cmake-optional-components","title":"CMake - Optional Components","text":"<pre><code>add_compile_options(-std=c++17)\nset(CMAKE_CXX_STANDARD 17)\n\n# find components of a specific rmagine version\n# '2.2.8' will get the newest rmagine which \n# is greater equal 2.2.8\nfind_package(rmagine 2.2.8\n    COMPONENTS\n        core\n    OPTIONAL_COMPONENTS\n        embree\n        cuda\n        optix\n)\n\nif(TARGET rmagine::embree)\n    # Compile app with embree support,\n    # if rmagine::embree was found\n    add_executable(my_rmagine_embree_app \n        src/my_rmagine_embree_app.cpp)\n    target_link_libraries(my_rmagine_embree_app\n        rmagine::core\n        rmagine::embree\n    )\nendif(TARGET rmagine::embree)\n\nif(TARGET rmagine::optix)\n    # Compile app with optix support,\n    # if rmagine::optix was found\n    add_executable(my_rmagine_optix_app \n        src/my_rmagine_optix_app.cpp)\n    target_link_libraries(my_rmagine_optix_app\n        rmagine::core\n        rmagine::cuda\n        rmagine::optix\n    )\nendif(TARGET rmagine::optix)\n</code></pre>"},{"location":"extra/cmake_advanced/#cmake-fetchcontent","title":"CMake - FetchContent","text":"<p>Rmagine is compatible with CMake's FetchContent functionality. The following <code>CMakeListst.txt</code> shows how to use <code>FetchContent</code> and checks if the required targets have been built successfully.</p> <pre><code>cmake_minimum_required(VERSION 3.16)\nproject(my_rmagine_app)\n\nadd_compile_options(-std=c++17)\nset(CMAKE_CXX_STANDARD 17)\n\ninclude(FetchContent)\nset(FETCHCONTENT_QUIET FALSE)\nFetchContent_Declare(\n  rmagine\n  GIT_REPOSITORY https://github.com/uos/rmagine.git\n  GIT_TAG        v2.2.9 # put 'main' here for latest\n  GIT_PROGRESS   TRUE\n)\nFetchContent_MakeAvailable(rmagine)\n\nif(NOT TARGET rmagine::embree)\n    message(FATAL \"Could not build rmagine's embree backand which is required for this executable\")\nendif(NOT TARGET rmagine::embree)\n\nadd_executable(my_rmagine_embree_app\n    src/my_rmagine_embree_app.cpp)\ntarget_link_libraries(my_rmagine_embree_app\n    rmagine::core\n    rmagine::embree)\n</code></pre>"},{"location":"extra/contributions/","title":"Contributions","text":"<p>We are excited to invite you to contribute to our open source project Rmagine! Whether you're a seasoned developer, a documentation enthusiast, or someone with fresh ideas, your contributions can make a significant impact.</p>"},{"location":"extra/contributions/#how-you-can-help","title":"How You Can Help:","text":"<ol> <li> <p>Code Contributions: Help us improve the codebase by submitting pull requests. Whether it\u2019s fixing bugs, adding features, or optimizing existing code, every contribution counts!</p> </li> <li> <p>Documentation: Clear and comprehensive documentation is crucial. Assist us by correcting errors, enhancing content, or providing examples that make it easier for users to navigate and utilize the project.</p> </li> <li> <p>Feedback and Suggestions: Your insights matter! Share your thoughts on how we can improve the project. Opening issues with suggestions or feedback is a great way to get involved.</p> </li> </ol>"},{"location":"extra/data/","title":"Data","text":"<p>For development and testing we include some meshes inside our repository in the <code>dat</code>-folder: </p>"},{"location":"extra/data/#sphereply","title":"sphere.ply","text":"<pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_map_info ../dat/sphere.ply\nRmagine Map Info\nInputs: \n- filename: ../dat/sphere.ply\nMeshes: 1\n  Mesh 0\n    - name: \n    - vertices, faces: 642, 1280\n    - primitives: TRIANGLE\n    - normals: no\n    - vertex color channels: 0\n    - uv channels: 0\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\nTextures: 0\nScene Graph: \n- name: \n- transform: \n  M4x4[\n    1 0 0 0\n    0 1 0 0\n    0 0 1 0\n    0 0 0 1\n  ]\n- meshes: 1\n  - mesh ref 0 -&gt; 0\n- children: 0\n</code></pre>"},{"location":"extra/data/#triangleply","title":"triangle.ply","text":"<pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_map_info ../dat/triangle.ply\nRmagine Map Info\nInputs: \n- filename: ../dat/triangle.ply\nMeshes: 1\n  Mesh 0\n    - name: \n    - vertices, faces: 3, 1\n    - primitives: TRIANGLE\n    - normals: no\n    - vertex color channels: 0\n    - uv channels: 0\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\nTextures: 0\nScene Graph: \n- name: \n- transform: \n  M4x4[\n    1 0 0 0\n    0 1 0 0\n    0 0 1 0\n    0 0 0 1\n  ]\n- meshes: 1\n  - mesh ref 0 -&gt; 0\n- children: 0\n</code></pre>"},{"location":"extra/data/#box_rot_trans_scaleddae","title":"box_rot_trans_scaled.dae","text":"<pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_map_info ../dat/box_rot_trans_scaled.dae\nRmagine Map Info\nInputs: \n- filename: ../dat/box_rot_trans_scaled.dae\nMeshes: 1\n  Mesh 0\n    - name: Cube-mesh\n    - vertices, faces: 36, 12\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\nTextures: 0\nScene Graph: \n- name: Scene\n- transform: \n  M4x4[\n    1 0 0 0\n    0 1 0 0\n    0 0 1 0\n    0 0 0 1\n  ]\n- meshes: 0\n- children: 3\n  Node 0\n    - name: Camera\n    - transform: \n      M4x4[\n        0.727676 0.305421 -0.61417 -6.92579\n        -0.685921 0.324014 -0.651558 -7.35889\n        0 0.895396 0.445271 4.95831\n        0 0 0 1\n      ]\n    - meshes: 0\n    - children: 0\n  Node 1\n    - name: Light\n    - transform: \n      M4x4[\n        0.955171 -0.199883 0.218391 1.00545\n        0.290865 0.771101 -0.566393 -4.07624\n        -0.0551891 0.604525 0.794672 5.90386\n        0 0 0 1\n      ]\n    - meshes: 0\n    - children: 0\n  Node 2\n    - name: Cube\n    - transform: \n      M4x4[\n        0.141421 0.141421 0 0\n        -0.141421 0.141421 0 -5\n        0 0 0.2 0\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 0\n    - children: 0\n</code></pre>"},{"location":"extra/data/#two_cubesdae","title":"two_cubes.dae","text":"<pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_map_info ../dat/two_cubes.dae\nRmagine Map Info\nInputs: \n- filename: ../dat/two_cubes.dae\nMeshes: 2\n  Mesh 0\n    - name: Cube_001-mesh\n    - vertices, faces: 36, 12\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 1\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\n  Mesh 1\n    - name: Cube-mesh\n    - vertices, faces: 36, 12\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\nTextures: 0\nScene Graph: \n- name: Scene\n- transform: \n  M4x4[\n    1 0 0 0\n    0 1 0 0\n    0 0 1 0\n    0 0 0 1\n  ]\n- meshes: 0\n- children: 4\n  Node 0\n    - name: Cube_001\n    - transform: \n      M4x4[\n        1 0 0 5.01877\n        0 1 0 3.78582\n        0 0 1 1.01026\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 0\n    - children: 0\n  Node 1\n    - name: Camera\n    - transform: \n      M4x4[\n        0.685921 -0.324014 0.651558 7.35889\n        0.727676 0.305421 -0.61417 -6.92579\n        0 0.895396 0.445271 4.95831\n        0 0 0 1\n      ]\n    - meshes: 0\n    - children: 0\n  Node 2\n    - name: Light\n    - transform: \n      M4x4[\n        -0.290865 -0.771101 0.566393 4.07624\n        0.955171 -0.199883 0.218391 1.00545\n        -0.0551891 0.604525 0.794672 5.90386\n        0 0 0 1\n      ]\n    - meshes: 0\n    - children: 0\n  Node 3\n    - name: Cube\n    - transform: \n      M4x4[\n        1.64731 1.34142 -0.299005 5.7392\n        -1.28721 1.34237 -1.06938 -4.66034\n        -0.481559 1.00054 1.83561 1.69496\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 1\n    - children: 0\n</code></pre>"},{"location":"extra/data/#many_objectsdae","title":"many_objects.dae","text":"<pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_map_info ../dat/many_objects.dae\nRmagine Map Info\nInputs: \n- filename: ../dat/many_objects.dae\nMeshes: 7\n  Mesh 0\n    - name: Torus-mesh\n    - vertices, faces: 3456, 1152\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\n  Mesh 1\n    - name: Suzanne-mesh\n    - vertices, faces: 2901, 967\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\n  Mesh 2\n    - name: Cone-mesh\n    - vertices, faces: 186, 62\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\n  Mesh 3\n    - name: Cylinder-mesh\n    - vertices, faces: 372, 124\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\n  Mesh 4\n    - name: Plane-mesh\n    - vertices, faces: 6, 2\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\n  Mesh 5\n    - name: Cube_001-mesh\n    - vertices, faces: 36, 12\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 1\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\n  Mesh 6\n    - name: Cube-mesh\n    - vertices, faces: 36, 12\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\nTextures: 0\nScene Graph: \n- name: Scene\n- transform: \n  M4x4[\n    1 0 0 0\n    0 1 0 0\n    0 0 1 0\n    0 0 0 1\n  ]\n- meshes: 0\n- children: 10\n  Node 0\n    - name: Torus\n    - transform: \n      M4x4[\n        -0.0934659 -0.290695 2.78847 -9.244\n        0.942502 2.62438 0.30518 5.28275\n        -2.64041 0.94707 0.0102276 3.4012\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 0\n    - children: 0\n  Node 1\n    - name: Suzanne\n    - transform: \n      M4x4[\n        -0.247416 -0.65867 0.71059 -6.41007\n        0.442643 -0.729225 -0.521823 -2.72992\n        0.861889 0.18543 0.471977 1.71339\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 1\n    - children: 0\n  Node 2\n    - name: Cone\n    - transform: \n      M4x4[\n        1 0 0 1.73173\n        0 1 0 -7.66226\n        0 0 1 0.999599\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 2\n    - children: 0\n  Node 3\n    - name: Cylinder\n    - transform: \n      M4x4[\n        1 0 0 1.34234\n        0 1 0 8.77874\n        0 0 1 0.959374\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 3\n    - children: 0\n  Node 4\n    - name: Plane\n    - transform: \n      M4x4[\n        11 0 0 0\n        0 11 0 0\n        0 0 11 0\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 4\n    - children: 0\n  Node 5\n    - name: Light_001\n    - transform: \n      M4x4[\n        -0.290865 -0.771101 0.566393 4.07624\n        0.955171 -0.199883 0.218391 1.00545\n        -0.0551891 0.604525 0.794672 5.90386\n        0 0 0 1\n      ]\n    - meshes: 0\n    - children: 0\n  Node 6\n    - name: Cube_001\n    - transform: \n      M4x4[\n        0.84132 0.52049 0.145848 5.72826\n        -0.452094 0.52966 0.717685 3.24672\n        0.296298 -0.669739 0.680923 3.1261\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 5\n    - children: 0\n  Node 7\n    - name: Camera\n    - transform: \n      M4x4[\n        0.685921 -0.324014 0.651558 7.35889\n        0.727676 0.305421 -0.61417 -6.92579\n        0 0.895396 0.445271 4.95831\n        0 0 0 1\n      ]\n    - meshes: 0\n    - children: 0\n  Node 8\n    - name: Light\n    - transform: \n      M4x4[\n        -0.290865 -0.771101 0.566393 4.07624\n        0.955171 -0.199883 0.218391 1.00545\n        -0.0551891 0.604525 0.794672 5.90386\n        0 0 0 1\n      ]\n    - meshes: 0\n    - children: 0\n  Node 9\n    - name: Cube\n    - transform: \n      M4x4[\n        1 0 0 4.91178\n        0 1 0 -2.96374\n        0 0 1 1.06244\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 6\n    - children: 0\n</code></pre>"},{"location":"extra/embree3/","title":"Embree 3","text":"<p>Follow the following steps if you want Rmagine to work with Embree 3:</p> <pre><code>user@pc:~$ git clone https://github.com/embree/embree.git --branch v3.13.5\nuser@pc:~$ mkdir embree/build &amp;&amp; cd embree/build\nuser@pc:~/embree/build$ cmake -DCMAKE_BUILD_TYPE=Release ..\nuser@pc:~/embree/build$ make -j`nproc`\nuser@pc:~/embree/build$ sudo make install\n</code></pre> <p>During the <code>cmake</code>-process errors could occur. The following flags could fix it. You can edit them by calling <code>ccmake .</code> in build directory.</p> <pre><code># The Intel Implicit SPMD Program Compiler is not necessarily needed \nEMBREE_ISPC_SUPPORT=OFF\n# Tasking system: TBB/Internal. You can choose INTERNAL if TBB is not installed\nEMBREE_TASKING_SYSTEM=INTERNAL \n# Tutials are not needed for library compilation\nEMBREE_TUTORIALS=OFF\n</code></pre> <p>Or you can pass the arguments directly to cmake for the minimal build <pre><code>cmake -DCMAKE_BUILD_TYPE=Release -DEMBREE_ISPC_SUPPORT=OFF -DEMBREE_TASKING_SYSTEM=INTERNAL -DEMBREE_TUTORIALS=OFF ..\n</code></pre></p>"},{"location":"extra/news/","title":"News","text":""},{"location":"extra/news/#05122023","title":"05.12.2023","text":"<p>New version 2.2.2 is available now and brings convenience updates for ROS-users. Just place Rmagine into your ROS-workspace and it will compile. Via <code>find_package(rmagine COMPONENTS [...])</code> you can still find Rmagine's components as if you would install it globally on your system. We tested it with  - ROS1 - noetic - ROS2 - humble</p> <p>Normally you would set <code>OptiX_INCLUDE_DIR</code> via cmake flags. Now we provide an additional option: Set the environment variable <code>OPTIX_HEADER_DIR</code> for example in your <code>.bashrc</code>-file:</p> <pre><code>export OPTIX_INCLUDE_DIR=~/software/optix/NVIDIA-OptiX-SDK-7.4.0-linux64-x86_64/include\n</code></pre> <p>Especially if you place Rmagine into your ROS-workspace this option becomes very handy.</p>"},{"location":"extra/news/#27092023","title":"27.09.2023","text":"<p>From version &gt;= 2.2.0 we enabled component-wise compilation and packaging for easier installation of Rmagine. In \"Releases\" section you can find the first pre-compiled binaries. Install the core library via</p> <pre><code>$ sudo dpkg -i rmagine-core_2.2.1_amd64.deb\n</code></pre> <p>Then additionally for the Embree backend:</p> <pre><code>$ sudo dpkg -i rmagine-embree_2.2.1_amd64.deb\n</code></pre> <p>And if you have a NVIDIA GPU:</p> <pre><code>$ sudo dpkg -i rmagine-cuda_2.2.1_amd64.deb\n$ sudo dpkg -i rmagine-optix_2.2.1_amd64.deb\n</code></pre> <p>Using the pre-compiled binaries, you are not required to download the OptiX-headers anymore. However, CUDA and Embree are still required to be installed on your system.</p>"},{"location":"extra/styleguide/","title":"Styleguide","text":""},{"location":"extra/styleguide/#naming-conventions","title":"Naming Conventions","text":""},{"location":"extra/styleguide/#files","title":"Files","text":"<ul> <li>Files containing a single C++-Class are written camelcase with <code>.hpp</code> extension. Examples: <code>MyClass.hpp</code> (Header), <code>MyClass.cpp</code> (Code), and <code>MyClass.tcc</code> (Template Code).</li> <li>Files holding a set of Structs, Classes, or Functions are written lowercase with <code>.h</code> extension. Examples: <code>math/types.h</code>, <code>conversions.h</code>, or <code>math.h</code> (Header) and <code>conversions.cpp</code> for code.</li> <li>Files holding Functions with CUDA code are namend with a <code>.cuh</code> extension: <code>math.cuh</code></li> </ul>"},{"location":"extra/styleguide/#code","title":"Code","text":"<ul> <li>Functions with underscores: <code>mult</code>, <code>my_function</code> </li> <li>Classes and Structs in camelcase beginning with a capital letter: <code>Sphere</code>, <code>SphereSimulatorEmbree</code></li> <li>Class Functions are beginning lowercase and then camelcase: <code>mult</code>, <code>simulateRanges</code></li> </ul> <p>TODO: revise files to meet this styleguide</p>"},{"location":"extra/styleguide/#special-operators-for-math-types","title":"Special Operators for Math Types","text":"<ul> <li><code>~</code>: Invert the element after</li> </ul>"},{"location":"extra/tools/","title":"Tools","text":"<p>There are some helpful command line tools that are compiled alongside the main library. After installation the tools are globally available to be called.</p>"},{"location":"extra/tools/#rmagine_version","title":"rmagine_version","text":"<p>Prints the rmagine version. Should match the CMakeLists version.</p> <pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_version\n2.2.1\n</code></pre>"},{"location":"extra/tools/#rmagine_benchmark","title":"rmagine_benchmark","text":"<p>For every implemented computing device we compile a benchmark executable that simulates a Velodyne LiDAR sensor in a given mesh and prints out some useful run time statisitics. Thus, we can compare the run times of different implementations on several computers. The CPU / Embree version can be tested like this:</p> <pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_benchmark_cpu ../dat/sphere.ply\nRmagine Benchmark CPU (Embree)\nInputs: \n- mesh: ../dat/sphere.ply\nUnit: 1 Velodyne scan (velo) = 14400 Rays\n- range of last ray: 0.998762\n-- Starting Benchmark --\n[ 129% - 2215.605926 velos/s, mean: 2387.607002 velos/s] \nResult: 2387.607002 velos/s\n</code></pre> <p>Analogously, the GPU benchmark can be started as follows:</p> <pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_benchmark_gpu ../dat/sphere.ply\n[RMagine - CudaContext] CUDA Driver Version / Runtime Version: 12.2.0 / 12.2.0\n[RMagine - CudaContext] Construct context on device 0 - NVIDIA GeForce RTX 2060 \n[RMagine - OptixContext] Init Optix (7.3.0). Required GPU driver &gt;= 465.84\nRmagine Benchmark GPU (OptiX)\nInputs: \n- mesh: ../dat/sphere.ply\nUnit: 1 Velodyne scan (velo) = 14400 Rays\nLast Ray:\n- range: 0.998762\n-- Starting Benchmark --\n[ 100% - 231941.938409 velos/s, mean: 231987.481164 velos/s] \nResult: 231987.481164 velos/s\n</code></pre>"},{"location":"extra/tools/#rmagine_map_info","title":"rmagine_map_info","text":"<p>Prints useful information about the contents of a mesh file. Internally it is just printing the meta information of the assimp buffers.</p> <pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_map_info ../dat/two_cubes.dae\nRmagine Map Info\nInputs: \n- filename: ../dat/two_cubes.dae\nMeshes: 2\n  Mesh 0\n    - name: Cube_001-mesh\n    - vertices, faces: 36, 12\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 1\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\n  Mesh 1\n    - name: Cube-mesh\n    - vertices, faces: 36, 12\n    - primitives: TRIANGLE\n    - normals: yes\n    - vertex color channels: 0\n    - uv channels: 1\n    - bones: 0\n    - material index: 0\n    - tangents and bitangents: no\n    - aabb: AABB [v[0,0,0] - v[0,0,0]]\nTextures: 0\nScene Graph: \n- name: Scene\n- transform: \n  M4x4[\n    1 0 0 0\n    0 1 0 0\n    0 0 1 0\n    0 0 0 1\n  ]\n- meshes: 0\n- children: 4\n  Node 0\n    - name: Cube_001\n    - transform: \n      M4x4[\n        1 0 0 5.01877\n        0 1 0 3.78582\n        0 0 1 1.01026\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 0\n    - children: 0\n  Node 1\n    - name: Camera\n    - transform: \n      M4x4[\n        0.685921 -0.324014 0.651558 7.35889\n        0.727676 0.305421 -0.61417 -6.92579\n        0 0.895396 0.445271 4.95831\n        0 0 0 1\n      ]\n    - meshes: 0\n    - children: 0\n  Node 2\n    - name: Light\n    - transform: \n      M4x4[\n        -0.290865 -0.771101 0.566393 4.07624\n        0.955171 -0.199883 0.218391 1.00545\n        -0.0551891 0.604525 0.794672 5.90386\n        0 0 0 1\n      ]\n    - meshes: 0\n    - children: 0\n  Node 3\n    - name: Cube\n    - transform: \n      M4x4[\n        1.64731 1.34142 -0.299005 5.7392\n        -1.28721 1.34237 -1.06938 -4.66034\n        -0.481559 1.00054 1.83561 1.69496\n        0 0 0 1\n      ]\n    - meshes: 1\n      - mesh ref 0 -&gt; 1\n    - children: 0\n</code></pre>"},{"location":"extra/tools/#rmagine_synthetic","title":"rmagine_synthetic","text":"<p>Generate different meshes for quick testing. Show the possible options by entering</p> <pre><code>user@pc:~/rmagine/build$ ./bin/rmagine_synthetic\nRmagine Synthetic\nUsage: ./bin/rmagine_synthetic mesh_type mesh_file\n- mesh_type: plane | cube | sphere | cylinder \n</code></pre> <code>rmagine_synthetic plane plane.ply</code> <code>rmagine_synthetic cube cube.ply</code> <code>rmagine_synthetic sphere sphere.ply</code> <code>rmagine_synthetic cylinder cylinder.ply</code>"},{"location":"getting_started/maps/","title":"Maps","text":"<p>Triangle meshes can be stored in various file formats. Rmagine utilizes the Open Asset Import Library (assimp) in order to support a wide range of well known file formats. After loading the raw scene graph buffers with Assimp, they are converted into Rmagines internal scene graph structure. Dependent on the computation backend <code>Embree</code> or <code>OptiX</code> the scene graph is prepared for fast ray traversals by building the required acceleration structures.</p>"},{"location":"getting_started/maps/#embree-map","title":"Embree Map","text":"<pre><code>#include &lt;rmagine/map/EmbreeMap.hpp&gt;\n\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    std::string filename = \"path/to/mesh/file\";\n    rm::EmbreeMapPtr map = rm::import_embree_map(filename);\n    return 0;\n}\n</code></pre>"},{"location":"getting_started/maps/#optix-map","title":"OptiX Map","text":"<pre><code>#include &lt;rmagine/map/OptixMap.hpp&gt;\n\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    std::string filename = \"path/to/mesh/file\";\n    rm::OptixMapPtr map = rm::import_optix_map(filename);\n    return 0;\n}\n</code></pre>"},{"location":"getting_started/maps/#properties","title":"Properties","text":"<p>After loading, the map consists of a complete scene graph. It then usually is passed to a simulator (see next \"Getting Started\"-sections). The advanced Map-section describes how to modify or create the internal maps from scratch.</p>"},{"location":"getting_started/noise/","title":"Noise","text":"<p>Currently noise models are implemented as postprocessing steps that modify the simulated ranges. Any of the following noise models can be chained to generate complex combined noise models. The Noise models are implemented equally both for GPU and CPU. Thus the developer can apply noise to the data without downloading or uploading the data from GPU to CPU or vice versa.</p> <ol> <li>Gaussian Noise</li> </ol> <p>Apply gaussian noise $N(\\mu, \\sigma)$ to simulated ranges.</p> Parameter Description <code>mean</code> Mean $\\mu$ of normal distributed noise <code>stddev</code> standard deviation $\\sigma$ of normal distributed noise <p></p> <p>Example CPU:</p> <pre><code>#include &lt;rmagine/noise/GaussianNoise.hpp&gt;\nnamespace rm = rmagine;\n\n// what happend before:\n// - data was simulated and stored into variable 'res'\n\n// make a copy to keep the unnoised ranges\nrm::Memory&lt;float, rm::RAM&gt; ranges = res.ranges;\n\n// Base class: Noise\nfloat mean = 0.0;\nfloat stddev = 1.0;\nrm::NoisePtr noise = std::make_shared&lt;rm::GaussianNoise&gt;(\n    mean, stddev);\n\n// apply noise\nnoise-&gt;apply(ranges);\n// ranges now contains noise\n</code></pre> <p>Example CUDA:</p> <pre><code>#include &lt;rmagine/noise/GaussianNoiseCuda.hpp&gt;\nnamespace rm = rmagine;\n\n// what happend before:\n// - data was simulated and stored into variable 'res'\n\n\n// make a copy to keep unnoised ranges\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; ranges = res.ranges;\n\n// Base class: NoiseCuda\nfloat mean = 0.0;\nfloat stddev = 1.0;\nrm::NoiseCudaPtr noise = std::make_shared&lt;rm::GaussianNoiseCuda&gt;(\n    mean, stddev);\n\n// apply noise\nnoise-&gt;apply(ranges);\n// ranges now contains noise\n</code></pre> <ol> <li>Relative Gaussian Noise</li> </ol> <p>Apply gaussian noise $N(\\mu, \\sigma_r)$ to simulated ranges. Here, the standard deviation varies depending on distance.</p> Parameter Description <code>mean</code> Mean $\\mu$ of normal distributed noise <code>stddev</code> standard deviation $\\sigma$ of normal distributed noise <code>range_exp</code> range exponent $c$ to compute range based stddev: $ \\sigma_r = \\sigma \\cdot r^{c} $ <p></p> <p>Example CPU:</p> <pre><code>#include &lt;rmagine/noise/RelGaussianNoise.hpp&gt;\nnamespace rm = rmagine;\n\n// what happend before:\n// - data was simulated and stored into variable 'res'\n\n// make a copy to keep the unnoised ranges\nrm::Memory&lt;float, rm::RAM&gt; ranges = res.ranges;\n\n// Base class: Noise\nfloat mean = 0.0;\nfloat stddev = 0.2;\nfloat range_exp = 1.1;\nrm::NoisePtr noise = std::make_shared&lt;rm::RelGaussianNoise&gt;(\n    mean, stddev, range_exp);\n\n// apply noise\nnoise-&gt;apply(ranges);\n// ranges now contains noise\n</code></pre> <p>Example CUDA:</p> <pre><code>#include &lt;rmagine/noise/RelGaussianNoiseCuda.hpp&gt;\nnamespace rm = rmagine;\n\n// what happend before:\n// - data was simulated and stored into variable 'res'\n\n\n// make a copy to keep unnoised ranges\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; ranges = res.ranges;\n\n// Base class: NoiseCuda\nfloat mean = 0.0;\nfloat stddev = 0.2;\nfloat range_exp = 1.1;\nrm::NoiseCudaPtr noise = std::make_shared&lt;rm::RelGaussianNoiseCuda&gt;(\n    mean, stddev, range_exp);\n\n// apply noise\nnoise-&gt;apply(ranges);\n// ranges now contains noise\n</code></pre> <ol> <li>Uniform Dust Noise</li> </ol> <p>Apply uniform dust noise to simulated ranges. Assuming some small particles could be hit by the range sensor that are not modeled by the scene, use this noise type. </p> <p>Parameters:</p> Parameter Description <code>hit_prob</code> Probability of a ray hitting a particle in one meter free space. <code>return_prob</code> Probability of a ray hitting dust returns to sender depending on particle distance <p></p> <p>Example CPU:</p> <pre><code>#include &lt;rmagine/noise/UniformDustNoise.hpp&gt;\nnamespace rm = rmagine;\n\n// what happend before:\n// - data was simulated and stored into variable 'res'\n\n// make a copy to keep the unnoised ranges\nrm::Memory&lt;float, rm::RAM&gt; ranges = res.ranges;\n\n// Base class: Noise\nfloat hit_prob = 0.0;\nfloat ret_prob = 1.0;\nrm::NoisePtr noise = std::make_shared&lt;rm::UniformDustNoise&gt;(\n    hit_prob, ret_prob);\n\n// apply noise\nnoise-&gt;apply(ranges);\n// ranges now contains noise\n</code></pre> <p>Example CUDA:</p> <pre><code>#include &lt;rmagine/noise/UniformDustNoiseCuda.hpp&gt;\nnamespace rm = rmagine;\n\n// what happend before:\n// - data was simulated and stored into variable 'res'\n\n\n// make a copy to keep unnoised ranges\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; ranges = res.ranges;\n\n// Base class: NoiseCuda\nfloat hit_prob = 0.0;\nfloat ret_prob = 1.0;\nrm::NoiseCudaPtr noise = std::make_shared&lt;rm::UniformDustNoiseCuda&gt;(\n    hit_prob, ret_prob);\n\n// apply noise\nnoise-&gt;apply(ranges);\n// ranges now contains noise\n</code></pre>"},{"location":"getting_started/problem_modelling/","title":"Problem Modelling","text":"<p>The general computing flow is as follows. </p> <p></p> <p>Tsb is the transform from sensor to base frame. Or in other words: The sensor pose relative to the robot base. The map can be either a pointer to an <code>EmbreeMap</code> or <code>OptixMap</code>. The Prefix of the <code>Simulator</code> is either <code>Embree</code> for CPU computation or <code>Optix</code> for GPU computation. The suffix of the Simulator is dependent on which sensor model you want to simulate. A few examples:</p> <ul> <li><code>SphereSimulatorEmbree</code> - Simulate a velodyne on CPU</li> <li><code>PinholeSimulatorOptix</code>- Simulate a depth camera on GPU</li> <li><code>O1DnSimulatorOptix</code> - Simulate a custom <code>O1DnModel</code> on GPU </li> </ul>"},{"location":"getting_started/problem_modelling/#example-1-simulate-1000-3d-lidars-on-cpu","title":"Example 1: Simulate 1000 3D LiDaRs on CPU","text":"<p>Now we want to construct the following pipeline.</p> <p></p> <pre><code>#include &lt;rmagine/simulation/SphereSimulatorEmbree.hpp&gt;\n\nusing namespace rmagine;\n\nSphereSimulatorEmbreePtr construct_simulator(std::string path_to_mesh)\n{\n    // Default construct the SphereSimulatorEmbree as shared pointer\n    SphereSimulatorEmbreePtr sim = std::make_shared&lt;SphereSimulatorEmbree&gt;();\n\n    EmbreeMapPtr map = import_embree_map(path_to_mesh);\n    sim-&gt;setMap(map);\n\n    // Define sensor model\n    SphericalModel model;\n    // TODO: fill with model specific parameters\n    sim-&gt;setModel(model);\n\n    // Set static transform between sensor and base (optional)\n    Transform Tsb;\n    Tsb.setIdentity();\n    sim-&gt;setTsb(Tsb);\n\n    return sim;\n}\n\nint main(int argc, char** argv)\n{\n    // Load map and set map pointer to simulator\n    std::string path_to_mesh = argv[1];\n    SphereSimulatorEmbreePtr sim = construct_simulator(path_to_mesh);\n\n    // Define 1000 poses to simulate from\n    Memory&lt;Transform, RAM&gt; poses(1000);\n    for(int i = 0; i&lt;poses.size(); i++)\n    {\n        poses[i].setIdentity();\n    }\n\n    // add your desired attributes at intersection here\n    using ResultT = Bundle&lt;\n        Ranges&lt;RAM&gt; \n    &gt;;\n\n    // Result: Simulate Ranges\n    ResultT res = sim-&gt;simulate&lt;ResultT&gt;(poses_);\n    // res.ranges holds a buffer to the ranges\n\n    return 0;\n}\n</code></pre>"},{"location":"getting_started/problem_modelling/#example-2-simulate-1000-lidars-on-gpu","title":"Example 2: Simulate 1000 LiDaRs on GPU","text":"<p>Now we want to construct the following pipeline.</p> <p></p> <p>The green cells are memory objects on GPU as you see in the following code snippet.</p> <pre><code>#include &lt;rmagine/simulation/SphereSimulatorOptix.hpp&gt;\n\nusing namespace rmagine;\n\nSphereSimulatorOptixPtr construct_simulator(std::string path_to_mesh)\n{\n    // Default construct the SphereSimulatorEmbree as shared pointer\n    SphereSimulatorOptixPtr sim = std::make_shared&lt;SphereSimulatorOptix&gt;();\n\n    OptixMapPtr map = import_optix_map(path_to_mesh);\n    sim-&gt;setMap(map);\n\n    // Define sensor model\n    SphericalModel model;\n    // TODO: fill with model specific parameters\n    sim-&gt;setModel(model);\n\n    // Set static transform between sensor and base (optional)\n    Transform Tsb;\n    Tsb.setIdentity();\n    sim-&gt;setTsb(Tsb);\n\n    return sim;\n}\n\nint main(int argc, char** argv)\n{\n    // Load map and set map pointer to simulator\n    std::string path_to_mesh = argv[1];\n    SphereSimulatorOptixPtr sim = construct_simulator(path_to_mesh);\n\n    // Define 1000 poses to simulate from\n    Memory&lt;Transform, RAM&gt; poses(1000);\n    for(int i = 0; i&lt;poses.size(); i++)\n    {\n        poses[i].setIdentity();\n    }\n\n    // upload from CPU to GPU\n    Memory&lt;Transform, VRAM_CUDA&gt; poses_ = poses;\n\n    // add your desired attributes at intersection here\n    using ResultT = Bundle&lt;\n        Ranges&lt;VRAM_CUDA&gt; \n    &gt;;\n\n    // Result: Simulate Ranges\n    ResultT res = sim-&gt;simulate&lt;ResultT&gt;(poses_);\n\n    // download from GPU to CPU\n    // or use CUDA buffer for other computations\n    Memory&lt;float, RAM&gt; ranges = res.ranges;\n\n    return 0;\n}\n</code></pre>"},{"location":"getting_started/problem_modelling/#example-3-simulate-1000-lidars-on-gpu-and-images-on-cpu","title":"Example 3: Simulate 1000 LiDaRs on GPU and Images on CPU","text":"<p>Now we want to construct the following pipeline.</p> <p></p> <pre><code>#include &lt;rmagine/simulation/SphereSimulatorOptix.hpp&gt;\n#include &lt;rmagine/simulation/PinholeSimulatorEmbree.hpp&gt;\n\nusing namespace rmagine;\n\nint main(int argc, char** argv)\n{\n    // Load map and set map pointer to simulator\n    std::string path_to_mesh = argv[1];\n\n    // CONSTRUCTION PART\n\n    // Define Simulators\n    SphereSimulatorOptix lidar_sim_gpu;\n    PinholeSimulatorEmbree dcam_sim_cpu;\n\n    // Load and set maps\n    OptixMapPtr map_gpu = import_optix_map(path_to_mesh);\n    EmbreeMapPtr map_cpu = import_embree_map(path_to_mesh);\n    lidar_sim_gpu.setMap(map_gpu);\n    dcam_sim_cpu.setMap(map_cpu);\n\n\n    SphericalModel lidar_model;\n    PinholeModel dcam_model;\n    // TODO: Define models\n    lidar_sim_gpu.setModel(lidar_model);\n    dcam_sim_cpu.setModel(dcam_model);\n\n    // Define static transforms (optional)\n    Transform T_lidar_base;\n    Transform T_dcam_base;\n    lidar_sim_gpu.setTsb(T_lidar_base);\n    dcam_sim_cpu.setTsb(T_dcam_base);\n\n    // SIMULATION PART\n\n    Memory&lt;Transform, RAM&gt; poses(1000);\n    // TODO: fill poses\n\n    // upload from CPU to GPU\n    Memory&lt;Transform, VRAM_CUDA&gt; poses_ = poses;\n\n\n    // Simulate Depth cameras ranges on CPU\n    using ResultT_RAM = Bundle&lt;\n        Ranges&lt;RAM&gt; \n    &gt;;\n    ResultT_RAM dcam_res\n        = dcam_sim_cpu.simulate&lt;ResultT_RAM&gt;(poses);\n\n    // Simulate LiDaRs ranges on GPU\n    using ResultT_VRAM = Bundle&lt;\n        Ranges&lt;VRAM_CUDA&gt; \n    &gt;;\n    ResultT_VRAM lidar_res\n        = lidar_sim_gpu.simulate&lt;ResultT_VRAM&gt;(poses_);\n\n    // Download lidar ranges\n    Memory&lt;float, RAM&gt; lidar_ranges = lidar_res.ranges;\n\n    // Results are in dcam_res.ranges and lidar_ranges\n\n    return 0;\n}\n</code></pre>"},{"location":"getting_started/sensors/","title":"Supported Sensor Models","text":"<p>Rmagine supports several configurations of commonly used range sensors as Spherical, Pinhole or even fully customizable O1Dn and OnDn models. The following image shows how the results could look like using these different models.</p> <p> </p> <p>The next instructions show how to initialize each model individually.</p>"},{"location":"getting_started/sensors/#spherical","title":"Spherical","text":"<p>Spherical model for LiDARs.</p> <pre><code>struct SphericalModel\n{\n    DiscreteInterval phi;\n    DiscreteInterval theta;\n    Interval range;\n};\n</code></pre> <p>Example:</p> <pre><code>#include &lt;rmagine/types/sensor_models.h&gt;\nnamespace rm = rmagine;\n\n// ...\n\nrm::SphericalModel model;\n\nmodel.theta.min = -M_PI;\nmodel.theta.inc = 0.4 * M_PI / 180.0;\nmodel.theta.size = 900;\n\nmodel.phi.min = -15.0 * M_PI / 180.0;\nmodel.phi.inc = 2.0 * M_PI / 180.0;\nmodel.phi.size = 16;\n\nmodel.range.min = 0.0;\nmodel.range.max = 100.0;\n</code></pre>"},{"location":"getting_started/sensors/#pinhole","title":"Pinhole","text":"<p>Pinhole model for depth cameras.</p> <pre><code>struct PinholeModel\n{\n    uint32_t width;\n    uint32_t height;\n\n    Interval range;\n\n    float f[2]; // focal lengths fx, fy\n    float c[2]; // centroid cx, cy\n};\n</code></pre> <p>Example:</p> <pre><code>#include &lt;rmagine/types/sensor_models.h&gt;\nnamespace rm = rmagine;\n\n...\n\nrm::PinholeModel model;\nmodel.width = 200;\nmodel.height = 150;\nmodel.c[0] = 100.0;\nmodel.c[1] = 75.0;\nmodel.f[0] = 100.0;\nmodel.f[1] = 100.0;\nmodel.range.min = 0.0;\nmodel.range.max = 100.0;\n</code></pre>"},{"location":"getting_started/sensors/#o1dn","title":"O1Dn","text":"<p>Fully customizable model with one origin and N directions.</p> <pre><code>struct O1DnModel\n{\n    uint32_t width;\n    uint32_t height;\n\n    // maximum and minimum allowed range\n    Interval range;\n\n    // i-th ray = orig, dirs[i]\n    Vector orig; // One origin\n    Memory&lt;Vector&gt; dirs; // N directions\n};\n</code></pre> <p>Example:</p> <pre><code>#include &lt;rmagine/types/sensor_models.h&gt;\nnamespace rm = rmagine;\n\n...\n\nrm::O1DnModel model;\n\nmodel.orig.x = 0.0;\nmodel.orig.y = 0.0;\nmodel.orig.z = 0.0;\n\nmodel.width = 200;\nmodel.height = 1;\n\nmodel.dirs.resize(model.width * model.height);\n\nfloat step_size = 0.05;\n\nfor(int i=0; i&lt;200; i++)\n{\n    float y = - static_cast&lt;float&gt;(i - 100) * step_size;\n    float x = cos(y) * 2.0 + 2.0;\n    float z = -1.0;\n\n    model.dirs[i].x = x;\n    model.dirs[i].y = y;\n    model.dirs[i].z = z;\n\n    model.dirs[i].normalize();\n}\n\nmodel.range.min = 0.0;\nmodel.range.max = 100.0;\n</code></pre>"},{"location":"getting_started/sensors/#ondn","title":"OnDn","text":"<p>Fully customizable model with N origins and N directions.</p> <pre><code>struct OnDnModel\n{\n    uint32_t width;\n    uint32_t height;\n\n    Interval range;\n\n    // i-th ray = origs[i], dirs[i]\n    Memory&lt;Vector&gt; origs; // N origins\n    Memory&lt;Vector&gt; dirs; // N directions\n};\n</code></pre> <p>Example:</p> <pre><code>#include &lt;rmagine/types/sensor_models.h&gt;\nnamespace rm = rmagine;\n\n...\n\nrm::OnDnModel model;\n\nmodel.width = 200;\nmodel.height = 1;\n\nmodel.dirs.resize(model.width * model.height);\nmodel.origs.resize(model.width * model.height);\n\nfloat step_size = 0.05;\n\nfor(int i=0; i&lt;200; i++)\n{\n    float percent = static_cast&lt;float&gt;(i) / static_cast&lt;float&gt;(200);\n    float step = - static_cast&lt;float&gt;(i - 100) * step_size;\n    float y = sin(step);\n    float x = cos(step);\n\n    model.origs[i].x = 0.0;\n    model.origs[i].y = y * percent;\n    model.origs[i].z = x * percent;\n\n    model.dirs[i].x = 1.0;\n    model.dirs[i].y = 0.0;\n    model.dirs[i].z = 0.0;\n}\n\nmodel.range.min = 0.0;\nmodel.range.max = 100.0;\n</code></pre>"},{"location":"getting_started/sensors/#predefined-models","title":"Predefined models","text":"<p>Rmagine also provides some example models for testing. These are located in the <code>rmagine/types/sensors.h</code> Header-file and will be expanded in the future to include additional range sensors.</p> <pre><code>#include &lt;rmagine/types/sensors.h&gt;\nnamespace rm = rmagine;\n\n\n...\n\n// Velodyne VLP-16 with different horizontal resoultions\nrm::SphericalModel  velo_model_1 = rm::vlp16_900();\nrm::SphericalModel  velo_model_2 = rm::vlp16_360();\n\n\n// another examples for testing:\nrm::SphericalModel  ex_lidar    = rm::example_spherical();\nrm::PinholeModel    ex_pinhole  = rm::example_pinhole();\nrm::O1DnModel       ex_o1dn     = rm::example_o1dn();\nrm::OnDnModel       ex_ondn     = rm::example_ondn();\n</code></pre>"},{"location":"getting_started/simulation/","title":"Simulation","text":""},{"location":"getting_started/simulation/#requirements","title":"Requirements","text":"<p>Once a map is loaded and a sensor is defined anything is known to simulate the first range data.</p> <pre><code>// Map\n#include &lt;rmagine/map/EmbreeMap.hpp&gt;\n// Sensor Models\n#include &lt;rmagine/types/sensor_models.h&gt;\n// Simulators\n#include &lt;rmagine/simulation/SphereSimulatorEmbree.hpp&gt;\n\nnamespace rm = rmagine;\n\n// ...\n\n// loading a map\nstd::string path_to_mesh = \"my_mesh.ply\";\nrm::EmbreeMapPtr map = rm::load_embree_map(path_to_mesh);\n\n// defining a model\nrm::SphericalModel velo_model = rm::vlp16_900();\n\n// construct a simulator\nrm::SphereSimulatorEmbree sim;\nsim.setMap(map);\nsim.setModel(velo_model);\n\n// simulate ranges\n// ...\n</code></pre>"},{"location":"getting_started/simulation/#intersection-attributes","title":"Intersection Attributes","text":"Attribute Type Stride Description Hits uint8 1 If the a face was intersected (1) or not (0) Ranges float 1 Distance from ray origin along the direction to the first intersection Points float 3 Cartesian Coordinates of the Intersection (x,y,z) Normals float 3 Normal (nx, ny, nz) of intersected face FaceIds uint32 1 The id of the face that was intersected ObjectIds uint32 1 The id of the object that was intersected GeomIds uint32 1 The id of the geometry that was intersected"},{"location":"getting_started/simulation/#handle-results","title":"Handle Results","text":"<pre><code>// ...\n// Defined previously\n// - namespace rm = rmagine;\n// - SphereSimulatorEmbree sim;\n\n\n// 100 Transformations between base and map. e.g. poses of the robot\nrm::Memory&lt;rm::Transform, rm::RAM&gt; Tbm(100);\n\nfor(size_t i=0; i &lt; Tbm.size(); i++)\n{\n    rm::Transform T = rm::Transform::Identity();\n    T.t = {2.0, 0.0, 0.0}; // position (2,0,0)\n    rm::EulerAngles e = {0.0, 0.0, 1.0}; // orientation (0,0,1) radian - as euler angles\n    T.R.set(e); // euler internally converted to quaternion\n    Tbm[i] = T; // Write Transform/Pose to Memory\n}\n\n// add your desired attributes at intersection here\n// - optimizes the code at compile time\nusing ResultT = rm::Bundle&lt;\n    rm::Hits&lt;rm::RAM&gt;, \n    rm::Ranges&lt;rm::RAM&gt;\n&gt;;\n\n// Possible Attributes (rmagine/simulation/SimulationResults.hpp):\n// - Hits\n// - Ranges\n// - Points\n// - Normals\n// - FaceIds\n// - GeomIds\n// - ObjectIds\n\n// querying every attribute with 'rm::IntAttrAny' instead of 'ResultT'\n\nResultT result = sim.simulate&lt;ResultT&gt;(poses);\n// result.hits, result.ranges contain the resulting attribute buffers\nstd::cout &lt;&lt; \"printing the first ray's range: \" &lt;&lt; result.ranges[0] &lt;&lt; std::endl;\n\n// or slice the results for the scan of pose 5\nauto ranges5 = result.ranges(5 * model.size(), 6 * model.size());\nstd::cout &lt;&lt; \"printing the first ray's range of the fifth scan: \" &lt;&lt; ranges5[0] &lt;&lt; std::endl;\n\n// slicing and other useful operations will be described at another Wiki page.\n</code></pre>"},{"location":"getting_started/simulation/#todo-explain-tf-a-bit","title":"TODO: Explain TF a bit","text":""},{"location":"library/concepts/","title":"Key Concepts","text":"<p>Rmagine aims to perform computations flexible on selectable computing devices (CPU, GPU, ...). It also provides mechanisms to minimize graphical overheads and unnecessary copies between devices.</p>"},{"location":"library/concepts/#structure","title":"Structure","text":"<p>Rmagine has the following top-level structure of directories:</p> <ul> <li>Math - <code>rmagine/math</code></li> <li>Types - <code>rmagine/types</code></li> <li>Utilility - <code>rmagine/util</code></li> <li>Map - <code>rmagine/map</code></li> <li>Simulation - <code>rmagine/simulation</code></li> <li>Noise - <code>rmagine/noise</code></li> </ul>"},{"location":"library/concepts/#math","title":"Math","text":"<p>Contains all math related types and functions.  All math datatypes are completely CUDA compatible. See <code>rmagine/math/types.h</code> for all types. See Math section for more details.</p>"},{"location":"library/concepts/#types","title":"Types","text":"<p>Fundamental types required for simulations, e.g. sensor models. Depends on math types.</p>"},{"location":"library/concepts/#util","title":"Util","text":"<p>Utility functions. For exaple, including <code>rmagine/util/prints.h</code> lets you print every math types via <code>std::cout</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;rmagine/math/types.h&gt;\n#include &lt;rmagine/util/prints.h&gt;\n\nnamespace rm = rmagine;\n\nint main(int argc, char* argv)\n{\n    rm::Transform T = rm::Transform::Identity();\n    std::cout &lt;&lt; \"my transformation: \" &lt;&lt; T &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>The Stopwatch in <code>rmagine/util/StopWatch.hpp</code> lets you easily stop the runtime of a Code section.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;rmagine/util/StopWatch.hpp&gt;\n\nnamespace rm = rmagine;\n\nvoid demanding_function()\n{\n    // ...\n}\n\nint main(int argc, char* argv)\n{\n    rm::StopWatch sw;\n    double el;\n\n    sw();\n    demanding_function();\n    el = sw();\n    std::cout &lt;&lt; \"Demanding Function took \" &lt;&lt; el &lt;&lt; \" s\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"library/concepts/#map","title":"Map","text":"<p>All classes and functions that relate to map construction and map modifications. See Getting Started - Maps for a introduction to map loading. Go to Library - Maps for a more detailed descriptions of how to build Rmagine maps.</p>"},{"location":"library/concepts/#simulation","title":"Simulation","text":"<p>All classes and functions that relate to the actual simulations.</p>"},{"location":"library/concepts/#noise","title":"Noise","text":"<p>All classes and functions that relate to postprocessed noising. </p>"},{"location":"library/maps/","title":"Maps","text":""},{"location":"library/maps/#rmagine-scene-graph","title":"Rmagine Scene Graph","text":"<p>Rmagine provides datatypes for scene graphs. They are seperated into Embree and OptiX scene graphs to store a Scene Graph either on CPU or on GPU. Both of these Scene Graphs have a very similar interface but are slightly different. Thus are real shared interface is not implemented yet. In Rmagine, a scene graph holds Geometries, Instances and Scenes.</p>"},{"location":"library/maps/#geometry","title":"Geometry","text":"<p>A geometry is an abstract description of a physical object. Implemented Geometries are:</p> Concept Embree OptiX Mesh EmbreeMesh OptixMesh Points EmbreePoints - <p>We also implemented some shortcut meshes that are used in later examples. They are located in the files <code>rmagine/map/embree/embree_shapes.h</code> and <code>rmagine/map/optix/optix_shapes.h</code>.</p> ShortCut Mesh Embree OptiX Sphere <code>EmbreeSphere</code> <code>OptixSphere</code> Cube <code>EmbreeCube</code> <code>OptixCube</code> Plane <code>EmbreePlane</code> <code>OptixPlane</code> Cylinder <code>EmbreeCylinder</code> <code>OptixCylinder</code>"},{"location":"library/maps/#scene","title":"Scene","text":"<p>A scene is a set of geometries or a set of instances, each of which is assigned a position, an orientation, and a scale.</p>"},{"location":"library/maps/#instance","title":"Instance","text":"<p>An instance instantiates a given scene or geometry at a certain pose. Thus things can be instantiated without duplicating their memory. A classic example for that is 3D asteroids where the same asteroid geometry has to be spawned several times. Using different geometries would then bring the GPU memory to its limits. Instead, Instantiating one geometry several times leads to a more memory friendly way of solving this problem. In robotics one can think of a known geometry as a class, e.g. a chair. This chair can be placed several times in the map by instantiating it.</p>"},{"location":"library/maps/#scene-graph-embree","title":"Scene Graph Embree","text":""},{"location":"library/maps/#simple","title":"Simple","text":"<pre><code>#include &lt;rmagine/map/embree/EmbreeScene.hpp&gt;\n// shortcut meshes\n#include &lt;rmagine/map/embree/embree_shapes.h&gt;\n\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    // create a scene    \n    rm::EmbreeScenePtr scene = std::make_shared&lt;rm::EmbreeScene&gt;();\n\n    // create a sphere\n    rm::EmbreeMeshPtr sphere = std::make_shared&lt;rm::EmbreeSphere&gt;(1.0);\n    { // sphere settings\n        Transform T = Transform::Identity();\n        T.t.x = 1.0; // move sphere one unit along the x-axis \n        sphere-&gt;setTransform(T);\n        sphere-&gt;apply(); // apply transform related changes\n    }\n    sphere-&gt;commit(); // commit sphere\n\n    scene-&gt;add(sphere); // add sphere to scene\n    scene-&gt;commit(); // commit scene\n\n    // add the scene to a map. \n    rm::EmbreeMapPtr map = std::make_shared&lt;rm::EmbreeMap&gt;(scene);\n\n    // The map can then be used for simulations ...\n    return 0;\n}\n</code></pre>"},{"location":"library/maps/#instances","title":"Instances","text":"<pre><code>#include &lt;rmagine/map/embree/EmbreeScene.hpp&gt;\n#include &lt;rmagine/map/embree/EmbreeInstance.hpp&gt;\n// shortcut meshes\n#include &lt;rmagine/map/embree/embree_shapes.h&gt;\n\nnamespace rm = rmagine;\n\n/**\n * Create a Scene consisting of a sphere, a cube, and a cylinder\n */\nrm::EmbreeScenePtr create_scene()\n{\n    rm::EmbreeScenePtr scene = std::make_shared&lt;rm::EmbreeScene&gt;();\n\n    rm::EmbreeMeshPtr sphere = std::make_shared&lt;rm::EmbreeSphere&gt;(1.0);\n    { // sphere settings\n        Transform T = Transform::Identity();\n        T.t.y = -2.0; // move sphere two units right \n        sphere-&gt;setTransform(T);\n        sphere-&gt;apply(); // apply transform related changes\n    }\n    sphere-&gt;commit(); // commit sphere\n    scene-&gt;add(sphere); // add sphere to scene\n\n    rm::EmbreeMeshPtr cube = std::make_shared&lt;rm::EmbreeCube&gt;();\n    cube-&gt;commit(); // commit cube\n    scene-&gt;add(cube); // add cube to scene\n\n    auto cylinder = std::make_shared&lt;rm::EmbreeCylinder&gt;();\n    { // cylinder settings\n        Transform T = Transform::Identity();\n        T.t.y = 2.0; // move cylinder two units left \n        cylinder-&gt;setTransform(T);\n        cylinder-&gt;apply(); // apply transform related changes\n    }\n    cylinder-&gt;commit(); // commit cylinder\n    scene-&gt;add(cylinder); // add cylinder to scene\n\n    scene-&gt;commit(); // commit scene\n    return scene;\n}\n\nint main(int argc, char** argv)\n{\n    // create a scene    \n    auto scene = std::make_shared&lt;rm::EmbreeScene&gt;();\n\n    auto subscene = create_scene();\n\n    // add 100 instances of a subscene to a scene\n    for(size_t i=0; i&lt;100; i++)\n    {\n        rm::EmbreeInstancePtr subscene_inst = subscene-&gt;instantiate();\n        { // subscene_inst settings\n            rm::Transform T = rm::Transform::Identity();\n            T.t.x = (float)i; // moving instance 5 units to front\n            subscene_inst-&gt;setTransform(T);\n            subscene_inst-&gt;apply(); // apply transform related changes\n        }\n        subscene_inst-&gt;commit(); // commit instances\n        scene-&gt;add(subscene_inst); // add instance to scene\n    }\n\n    scene-&gt;commit();\n\n    // add the scene to a map. \n    rm::EmbreeMapPtr map = std::make_shared&lt;rm::EmbreeMap&gt;(scene);\n\n    // The map can then be used for simulations ...\n    return 0;\n}\n</code></pre>"},{"location":"library/maps/#custom-meshes","title":"Custom Meshes","text":"<pre><code>rm::EmbreeMeshPtr create_custom_mesh()\n{\n    size_t Nvertices = 3;\n    size_t Nfaces = 1;\n    auto mesh = std::make_shared&lt;rm::EmbreeMesh&gt;(Nvertices, Nfaces);\n\n    // reference to data as MemoryView objects\n    rm::MemoryView&lt;rm::Vertex, rm::RAM&gt; vertices = mesh-&gt;vertices();\n    rm::MemoryView&lt;rm::Face, rm::RAM&gt;   faces    = mesh-&gt;faces();\n\n    faces[0] = {0, 1, 2};\n    vertices[0] = {1.0, 0.0, 0.0};\n    vertices[1] = {0.0, 1.0, 0.0};\n    vertices[2] = {0.0, 0.0, 0.0};\n\n    return mesh;\n}\n\nint main(int argc, char** argv)\n{\n    auto scene = std::make_shared&lt;rm::EmbreeScene&gt;();\n\n    auto my_mesh = create_custom_mesh();\n    my_mesh-&gt;commit();\n\n    scene-&gt;add(my_mesh);\n    scene-&gt;commit();\n    // do something with scene ...\n    return 0;\n}\n</code></pre>"},{"location":"library/maps/#scene-graph-optix","title":"Scene Graph OptiX","text":""},{"location":"library/maps/#simple_1","title":"Simple","text":"<pre><code>#include &lt;rmagine/map/optix/OptixScene.hpp&gt;\n// shortcut meshes\n#include &lt;rmagine/map/optix/optix_shapes.h&gt;\n\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    // create a scene    \n    rm::OptixScenePtr scene = std::make_shared&lt;rm::OptixScene&gt;();\n\n    // create a sphere\n    rm::OptixMeshPtr sphere = std::make_shared&lt;rm::OptixSphere&gt;(1.0);\n    { // sphere settings\n        Transform T = Transform::Identity();\n        T.t.x = 1.0; // move sphere one unit along the x-axis \n        sphere-&gt;setTransform(T);\n        sphere-&gt;apply(); // apply transform related changes\n    }\n    sphere-&gt;commit(); // commit sphere\n\n    scene-&gt;add(sphere); // add sphere to scene\n    scene-&gt;commit(); // commit scene\n\n    // add the scene to a map. \n    rm::OptixMapPtr map = std::make_shared&lt;rm::OptixMap&gt;(scene);\n\n    // The map can then be used for simulations ...\n    return 0;\n}\n</code></pre>"},{"location":"library/maps/#instances_1","title":"Instances","text":"<pre><code>#include &lt;rmagine/map/optix/OptixScene.hpp&gt;\n#include &lt;rmagine/map/optix/OptixInstance.hpp&gt;\n// shortcut meshes\n#include &lt;rmagine/map/optix/optix_shapes.h&gt;\n\nnamespace rm = rmagine;\n\n/**\n * Create a Scene consisting of a sphere, a cube, and a cylinder\n */\nrm::OptixScenePtr create_scene()\n{\n    rm::OptixScenePtr scene = std::make_shared&lt;rm::OptixScene&gt;();\n\n    rm::OptixMeshPtr sphere = std::make_shared&lt;rm::OptixSphere&gt;(1.0);\n    { // sphere settings\n        Transform T = Transform::Identity();\n        T.t.y = -2.0; // move sphere two units right \n        sphere-&gt;setTransform(T);\n        sphere-&gt;apply(); // apply transform related changes\n    }\n    sphere-&gt;commit(); // commit sphere\n    scene-&gt;add(sphere); // add sphere to scene\n\n    rm::OptixMeshPtr cube = std::make_shared&lt;rm::OptixCube&gt;();\n    cube-&gt;commit(); // commit cube\n    scene-&gt;add(cube); // add cube to scene\n\n    auto cylinder = std::make_shared&lt;rm::OptixCylinder&gt;();\n    { // cylinder settings\n        Transform T = Transform::Identity();\n        T.t.y = 2.0; // move cylinder two units left \n        cylinder-&gt;setTransform(T);\n        cylinder-&gt;apply(); // apply transform related changes\n    }\n    cylinder-&gt;commit(); // commit cylinder\n    scene-&gt;add(cylinder); // add cylinder to scene\n\n    scene-&gt;commit(); // commit scene\n    return scene;\n}\n\nint main(int argc, char** argv)\n{\n    // create a scene    \n    auto scene = std::make_shared&lt;rm::OptixScene&gt;();\n\n    auto subscene = create_scene();\n\n    // add 100 instances of a subscene to a scene\n    for(size_t i=0; i&lt;100; i++)\n    {\n        rm::OptixInstancePtr subscene_inst = subscene-&gt;instantiate();\n        { // subscene_inst settings\n            rm::Transform T = rm::Transform::Identity();\n            T.t.x = (float)i; // moving instance 5 units to front\n            subscene_inst-&gt;setTransform(T);\n            subscene_inst-&gt;apply(); // apply transform related changes\n        }\n        subscene_inst-&gt;commit(); // commit instance\n        scene-&gt;add(subscene_inst); // add instance to scene\n    }\n\n    scene-&gt;commit();\n\n    // add the scene to a map. \n    rm::OptixMapPtr map = std::make_shared&lt;rm::OptixMap&gt;(scene);\n\n    // The map can then be used for simulations ...\n    return 0;\n}\n</code></pre>"},{"location":"library/math/","title":"Rmagine - Math-Library","text":"<p>Rmagine provides it's own thin math library. It's located in <code>rmagine::core</code> target. We decided to do so after having problems with Eigen in CUDA code (corrupt memory after using math functions). This thin math library was specifically designed to enable the sharing of functions between CPU and GPU code, and it has been tested to ensure consistent results for both CUDA and CPU implementations. The following descriptions are made reading the code located in <code>rmagine/math/types.h</code>. So it is recommended to open the file alongside.</p>"},{"location":"library/math/#points-and-translations","title":"Points and Translations","text":"<p>A floating-point coordinate can represent different things such as a point, a vector or the translational part of a transformation. For all of them, we provide the same data structure: <code>Vector</code>.</p> <ul> <li><code>rm::Vector2</code>: x,y all fp32</li> <li><code>rm::Vector3</code>: x,y,z all fp32</li> </ul> <p>Aliases: - <code>rm::Vector</code> = <code>rm::Vector3</code>; - <code>rm::Point</code> = <code>rm::Vector3</code>; - <code>rm::Vertex</code> = <code>rm::Vector3</code>;</p> <p>We also implemented commonly used functions <code>Vector</code>:</p> <pre><code>#include &lt;rmagine/math/types.h&gt;\nnamespace rm = rmagine;\n\n// ...\n\n// initializations\nrm::Vector3 p1;\np1.x = 0.0;\np1.y = 1.0;\np1.z = 2.0;\nrm::Vector3 p2 = {1.0, 2.0, 3.0};\n\n// functions\nfloat p1_length = p1.l2norm();\n\n// operators\nrm::Vector3 p3;\np3 = p1 + p2;\np3 = p1 - p2;\np3 = p1 * 2.0;\np3 = p1 / 2.0;\n\n// ...\n</code></pre>"},{"location":"library/math/#rotations","title":"Rotations","text":"<p>In Rmagine we provide three different representations of rotations: Euler angles (<code>rm::EulerAngles</code>), a rotation matrix (<code>rm::Matrix3x3</code>) and a quaternion (<code>rm::Quaternion</code>). In general, we adhere to the ROS conventions, especially those that are listed in REP-103.</p> <pre><code>#include &lt;rmagine/math/types.h&gt;\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    // EulerAngles\n    rm::EulerAngles e1;\n    e1.roll = 0.0;\n    e1.pitch = 0.0;\n    e1.yaw = M_PI / 2.0;\n    rm::EulerAngles e2 = {0.0, 0.0, M_PI / 2.0};\n    rm::EulerAngles eI = rm::EulerAngles::Identity();\n\n    // Quaternion\n    rm::Quaternion q1;\n    q1.x = 0.0;\n    q1.y = 0.0;\n    q1.z = 0.7071068;\n    q1.w = 0.7071068;\n    rm::Quaternion q2 = {0.0, 0.0, 0.7071068, 0.7071068};\n    rm::Quaternion qI = rm::Quaternion::Identity();\n\n    // Matrix3x3\n    // - Storage Order: Column-Major\n    // - Access via '()'-operator: Row-Major\n    // - Access via '[]'-operator: Column-Major\n    rm::Matrix3x3 M1;\n    M1(0,0) =  0.0; M1(0,1) = -1.0; M1(0,2) =  0.0;\n    M1(1,0) =  1.0; M1(1,1) =  0.0; M1(1,2) =  0.0;\n    M1(2,0) =  0.0; M1(2,1) =  0.0; M1(2,2) =  1.0;\n    rm::Matrix3x3 M2 = {{\n        {0.0, 1.0, 0.0},\n        {-1.0, 0.0, 0.0},\n        {0.0, 0.0, 1.0}\n    }};\n    rm::Matrix3x3 MI = rm::Matrix3x3::Identity();\n\n    return 0;\n}\n</code></pre>"},{"location":"library/math/#conversions","title":"Conversions","text":"<p>We provide conversions between different rotation representations:</p> <pre><code>#include &lt;rmagine/math/types.h&gt;\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    // initializations\n    rm::EulerAngles e;\n    rm::Matrix3x3 M;\n    rm::Quaterion q; \n\n    rm::Vector3 p = {1.0, 0.0, 0.0};\n\n    // rotation 90 degree around z-axis counter-clockwise\n    e.roll = 0.0;\n    e.pitch = 0.0;\n    e.yaw = M_PI / 2.0;\n\n    // convert\n    M.set(e); // set M values that express the same rotation as e\n    q.set(e); // set q values that express the same rotation as e\n\n    rm::Vector3 p1 = e * p;\n    rm::Vector3 p2 = M * p;\n    rm::Vector3 p3 = q * p;\n    // p1, p2 and p3 should all contain the values {0.0, 1.0, 0.0}\n\n    // other conversions:\n    q.set(M);\n    M.set(q);\n    e.set(M);\n    e.set(q);\n\n    return 0;\n}\n</code></pre> <p>and some math functions, e.g. to apply a rotation to another or to a point in space:</p> <pre><code>#include &lt;rmagine/math/types.h&gt;\nnamespace rm = rmagine;\nusing namespace rmagine;\n\nint main(int argc, char** argv)\n{\n    rm::EulerAngles e = {0.0, 0.0, M_PI/2.0};\n    rm::Quaternion q; q.set(e);\n    rm::Vector3 p = {1.0, 0.0, 0.0};\n\n    // Rotate a point 90 degrees around the z axis counter-clockwise\n    rm::Vector3 p1 = q * p;\n\n    // Chaining Rotations\n    // -&gt; Rotate a point 90 degrees around the z axis clockwise\n    rm::Quaternion q2 = q * q * q;\n    rm::Vector3 p2 = q2 * p;\n\n    // invert\n    rm::Quaternion q2_inv = q2.inv();\n    // or if 'using namespace rmagine;' was set, ~operator can be used\n    q2_inv = ~q2;\n\n    return 0;\n}\n</code></pre>"},{"location":"library/math/#eigen-compatibility","title":"Eigen Compatibility","text":"<p>We ensure compatibility with Eigen by sharing the same memory layout (for now). This allows to do fast mappings between rmagine and Eigen types.</p> <pre><code>#include &lt;rmagine/math/types.h&gt;\n#include &lt;Eigen/Dense&gt;\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    // Rmagine -&gt; Eigen\n    {\n        // generate rmagine type\n        rm::Matrix3x3    M_rm = rm::Matrix3x3::Identity();\n\n        // rmagine's Matrix3x3 has the same Column-Major storage order as the Eigen default for Eigen::Matrix3f\n        Eigen::Matrix3f&amp; M_eig = *reinterpret_cast&lt;Eigen::Matrix3f*&gt;(&amp;M_rm);\n\n        // another way is to use Eigens functions for mapping raw buffers\n        Eigen::Map&lt;Eigen::Matrix3f&gt; M_eig2(&amp;M_rm(0,0));\n\n        // changing an entry in M_rm should now change the same entry in M_eig and M_eig2 as well\n    }\n\n    // Eigen -&gt; Rmagine\n    {\n        Eigen::Matrix3f M_eig = Eigen::Matrix3f::Identity();\n        rm::Matrix3x3&amp; M_rm = *reinterpret_cast&lt;rm::Matrix3x3*&gt;(&amp;M_eig);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"library/math/#transformations","title":"Transformations","text":"<p>In Rmagine, a transformation (<code>rm::Transform</code>) is an operation that maps a source Euclidean space to a target Euclidean space, implemented as isometry, since we only implemented the rotational and translational part (no scale). We decided to represent the rotational part as quaternion (<code>rm::Quaternion</code>) to avoid gimbal locks that occur e.g. using an Euler angles representation.</p> <p>In Rmagine, we use a <code>Transform</code> type for a pose as well. A sensor pose entries correspond to a transformation that maps the space with the sensor as origin to the space where the pose is located:</p> <pre><code>#include &lt;rmagine/math/types.h&gt;\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    // pose of the sensor in the map\n    rm::Vector3 s_t = {0.0, 1.0, 2.0};\n    rm::Quaternion s_R = rm::Quaternion::Identity();\n\n    // has the same entries as the transform form sensor -&gt; map\n    rm::Transfrom T_sensor_to_map;\n    T_sensor_to_map.R = s_R;\n    T_sensor_to_map.t = s_t;\n\n    return 0;\n}\n</code></pre> <p>To express a transformation that is not isometric, for example because it consists of a scale part, use <code>rm::Matrix4x4</code> and the linear algebra functions of <code>rmagine/math/linalg.h</code> instead:</p> <pre><code>#include &lt;rmagine/math/types.h&gt;\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    // pose of the sensor in the map\n    rm::Transform T = {\n        rm::Quaternion::Identity(), // rotation\n        {0.0, 1.0, 2.0} // translation\n    };\n    rm::Vector3 s = {1.2, 1.2, 1.2}; // scale each dimension with 1.2\n\n    // pack to Matrix4x4\n    rm::Matrix4x4 M = rm::compose(T, s);\n\n    // Use M\n    rm::Vector3 p_sensor = {2.0, 1.0, 0.0};\n    rm::Vector3 p_map = M * p_sensor;\n\n    // unpack inverse: operator~ works only because of 'using namespace rmagine;'\n    // - Alternative: Matrix4x4::inv() \n    rm::decompose(~M, T, s);\n\n    return 0;\n}\n</code></pre>"},{"location":"library/math/#changing-precisions","title":"Changing Precisions","text":"<p>What you have used so far are all types that itself are aliases to specializations of templated math classes:</p> <p><pre><code>// defaults\n#define DEFAULT_FP_PRECISION 32\nusing DefaultFloatType = float;\n\n// default types\nusing Vector3 = Vector3_&lt;DefaultFloatType&gt;;\nusing Vector2 = Vector2_&lt;DefaultFloatType&gt;;\nusing Matrix2x2 = Matrix_&lt;DefaultFloatType, 2, 2&gt;;\nusing Matrix3x3 = Matrix_&lt;DefaultFloatType, 3, 3&gt;;\nusing Matrix4x4 = Matrix_&lt;DefaultFloatType, 4, 4&gt;;\nusing Quaternion = Quaternion_&lt;DefaultFloatType&gt;;\nusing EulerAngles = EulerAngles_&lt;DefaultFloatType&gt;;\nusing Transform = Transform_&lt;DefaultFloatType&gt;;\nusing AABB = AABB_&lt;DefaultFloatType&gt;;\n</code></pre> (Location: <code>rmagine/math/types/definitions.h</code>)</p> <p>However, Rmagine also supports other floating-point precisions such as double:</p> <p><pre><code>using Vector2f = Vector2_&lt;float&gt;;\nusing Vector2u = Vector2_&lt;uint32_t&gt;;\nusing Vector2i = Vector2_&lt;int32_t&gt;;\nusing Vector3f = Vector3_&lt;float&gt;;\nusing Matrix2x2f = Matrix_&lt;float, 2, 2&gt;;\nusing Matrix3x3f = Matrix_&lt;float, 3, 3&gt;;\nusing Matrix4x4f = Matrix_&lt;float, 4, 4&gt;;\nusing Quaternionf = Quaternion_&lt;float&gt;;\nusing EulerAnglesf = EulerAngles_&lt;float&gt;;\nusing Transformf = Transform_&lt;float&gt;;\nusing AABBf = AABB_&lt;float&gt;;\n\nusing Vector2d = Vector2_&lt;double&gt;;\nusing Vector3d = Vector3_&lt;double&gt;;\nusing Matrix2x2d = Matrix_&lt;double, 2, 2&gt;;\nusing Matrix3x3d = Matrix_&lt;double, 3, 3&gt;;\nusing Matrix4x4d = Matrix_&lt;double, 4, 4&gt;;\nusing Quaterniond = Quaternion_&lt;double&gt;;\nusing EulerAnglesd = EulerAngles_&lt;double&gt;;\nusing Transformd = Transform_&lt;double&gt;;\nusing AABBd = AABB_&lt;double&gt;;\n</code></pre> (Location: <code>rmagine/math/types/definitions.h</code>)</p> <p>In addition, this makes it possible to uses custom precisions, and still have the full range of functions available for both CPU and CUDA code.</p> <p>WARNING: The following code is a draft and was never tested, hence it doesn't neccesarily needs to compile. It shows how one would declare and use a 16 bit float vector.</p> <pre><code>#include &lt;cuda_fp16.hpp&gt;\nusing MyCudaHalfVector = rm::Vector3_&lt;__half&gt;;\n\n// add_inplace kernel\n// compute 'A[i] += B[i]', massively parallel on the GPU\n__global__ void add_inplace_kernel(\n    MyCudaHalfVector* vec_a,\n    const MyCudaHalfVector* vec_b, \n    size_t n)\n{\n    const unsigned int tid = threadIdx.x;   \n    if(tid &lt; n)\n    {\n        // this invokes a rmagine function using the \n        // using fp16 precision\n        vec_a[tid] += vec_b[tid];\n    }\n}\n\nint main(int argc, char** argv)\n{\n    // buffer of CUDA-half vectors located in RAM\n    rm::Memory&lt;MyCudaHalfVector, rm::RAM&gt; buffer_cpu(100);\n    // TODO fill buffer\n\n    // upload all CUDA-half vectors from RAM to VRAM_CUDA, twice\n    rm::Memory&lt;MyCudaHalfVector, rm::VRAM_CUDA&gt; buffer_a_gpu \n        = buffer_cpu;\n    rm::Memory&lt;MyCudaHalfVector, rm::VRAM_CUDA&gt; buffer_b_gpu \n        = buffer_cpu;\n\n    // call CUDA kernel 'add_inplace_kernel'\n    add_inplace_kernel&lt;&lt;&lt;buffer_gpu.size(), 1&gt;&gt;&gt;(\n        buffer_a_gpu.raw(),\n        buffer_b_gpu.raw(),\n        buffer_a_gpu.size());\n    // A[i]+=B[i] done.\n    // buffer_a_gpu contains changed elements now   \n\n    return 0;\n}\n</code></pre>"},{"location":"library/memory/","title":"Memory","text":""},{"location":"library/memory/#memory","title":"Memory","text":"<p>Rmagine internally uses so-called Memory objects to manage memory located on different hardware. The location where the actual memory should be allocated can be passed as a template argument using one of the following keywords:</p> <ul> <li><code>RAM</code> (RAM memory)</li> <li><code>RAM_CUDA</code> (pinned CUDA host memory)</li> <li><code>VRAM_CUDA</code> (CUDA device memory)</li> </ul> <p>After allocating the memory, accessing elements is similar to using <code>std::vector</code>'s:</p> <ul> <li>access element with <code>[]</code></li> <li>resize the memory with <code>resize()</code></li> <li>access raw data pointer with <code>raw()</code> function</li> </ul> <p>The following code samples are describing how to work with Memory objects and how to transfer Memory to other hardware.</p> <p>Example CPU-only:</p> <pre><code>#include &lt;rmagine/types/Memory.hpp&gt;\n\nnamespace rm = rmagine;\n\nint main(int argc, char** argv)\n{\n    // allocate memory with 1000 elements\n    rm::Memory&lt;float, rm::RAM&gt; mem(1000);\n\n    // shrink memory\n    mem.resize(100);\n\n    // set some values\n    mem[0] = 10.0;\n    mem[10] = 5.0;\n\n    return 0;\n}\n</code></pre> <p>Example GPU-only:</p> <pre><code>#include &lt;rmagine/types/MemoryCuda.hpp&gt;\n\nnamespace rm = rmagine;\n\n__global__\nvoid set_value(float* data, unsigned int id, float val)\n{\n    data[id] = val;\n}\n\nint main(int argc, char** argv)\n{\n    // allocate memory with 1000 elements on GPU\n    rm::Memory&lt;float, rm::VRAM_CUDA&gt; mem(1000);\n\n    // shrink memory on GPU\n    mem.resize(100);\n\n    // this would cause a segfault. since the underlying memory is not available\n    // on the device this code is executed:\n    // mem[0] = 10.0;\n    //\n    // set some values in Cuda kernels instead\n    set_value&lt;&lt;&lt;1,1&gt;&gt;&gt;(mem.raw(), 0, 10.0);\n    set_value&lt;&lt;&lt;1,1&gt;&gt;&gt;(mem.raw(), 10, 5.0);\n\n    return 0;\n}\n</code></pre> <p>Example CPU &lt;-&gt; CPU:</p> <pre><code>#include &lt;rmagine/types/Memory.hpp&gt;\n#include &lt;rmagine/types/MemoryCuda.hpp&gt;\n\nnamespace rm = rmagine;\n\n__global__ my_kernel(float* data, unsigned int N)\n{\n    // ...\n}\n\nint main(int argc, char** argv)\n{\n    // allocate memory with 1000 float elements\n    rm::Memory&lt;float, rm::RAM&gt; mem(1000);\n\n    // set some values\n    mem[0] = 10.0;\n    mem[10] = 5.0;\n\n    // copy the whole memory to GPU\n    rm::Memory&lt;float, rm::VRAM_CUDA&gt; mem_ = mem;\n\n    // run some kernels\n    my_kernel&lt;&lt;&lt;mem_.size(), 1&gt;&gt;&gt;(mem_.raw(), mem_.size());\n\n    // copy back\n    mem = mem_;\n\n    return 0;\n}\n</code></pre>"},{"location":"library/memory/#writing-memory-dependent-functions","title":"Writing Memory dependent Functions","text":"<p>With the memory objects Rmagine offers at the same time the possibility to make function calls dependent on the location of the memory. The next example adds two vectors and creates a new one. The actual addition should be executed on the device where the memory is currently stored on.</p> <pre><code>rm::Memory&lt;float, rm::RAM&gt; vec1(1000);\nrm::Memory&lt;float, rm::RAM&gt; vec2(1000);\n\n// fill vec1, vec2 ...\n\n// copy to GPU\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; vec1_ = vec1;\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; vec2_ = vec2;\n\n// we want to achieve this:\nauto vec3 = add(vec1, vec2);\nauto vec3_ = add(vec1_, vec2_);\n\n// ...\n</code></pre> <p>So we try to create a function <code>add(a, b)</code> whose code will be executed on the CPU once <code>a</code> and <code>b</code> are in RAM. However, as soon as <code>a</code> and <code>b</code> are stored on the GPU the code should be executed on the GPU as well as the function returns a GPU memory object. This can be done as follows:</p>"},{"location":"library/memory/#signatures-header","title":"Signatures (Header):","text":"<pre><code>rm::Memory&lt;float, rm::RAM&gt; add(\n    const rm::Memory&lt;float, rm::RAM&gt;&amp; a, \n    const rm::Memory&lt;float, rm::RAM&gt;&amp; b);\n\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; add(\n    const rm::Memory&lt;float, rm::VRAM_CUDA&gt;&amp; a, \n    const rm::Memory&lt;float, rm::VRAM_CUDA&gt;&amp; b);    \n</code></pre>"},{"location":"library/memory/#code-cpu","title":"Code CPU","text":"<pre><code>rm::Memory&lt;float, rm::RAM&gt; add(\n    const rm::Memory&lt;float, rm::RAM&gt;&amp; a, \n    const rm::Memory&lt;float, rm::RAM&gt;&amp; b)\n{\n    rm::Memory&lt;float, rm::RAM&gt; c(a.size());\n    for(size_t i=0; i &lt; a.size(); i++)\n    {\n        c[i] = a[i] + b[i];\n    }\n    return c;\n}\n</code></pre>"},{"location":"library/memory/#code-gpu","title":"Code GPU","text":"<pre><code>__global__\nvoid add_kernel(const float* a, const float* b, float* c, unsigned int N)\n{\n    const unsigned int id = blockIdx.x * blockDim.x + threadIdx.x;\n    if(id &lt; N)\n    {\n        c[id] = a[id] + b[id];\n    }\n}\n\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; add(\n    const rm::Memory&lt;float, rm::VRAM_CUDA&gt;&amp; a, \n    const rm::Memory&lt;float, rm::VRAM_CUDA&gt;&amp; b)\n{\n    rm::Memory&lt;float, rm::VRAM_CUDA&gt; c(a.size());\n    add_kernel&lt;&lt;&lt;c.size(), 1&gt;&gt;&gt;(a.raw(), b.raw(), c.raw(), c.size());\n    return c;\n}\n</code></pre> <p>Having these functions defined allows us to very flexible chain operations:</p> <pre><code>// Simple (as above):\nauto vec3 = add(vec1, vec2);\nauto vec3_ = add(vec1_, vec2_);\n\n// Advanced\n// - add two vectors on CPU and upload to GPU on return\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; vec3_ = add(vec1, vec2);\n// - add two vectors on GPU and download to CPU on return\nrm::Memory&lt;float, rm::RAM&gt; vec3 = add(vec1_, vec2_);\n</code></pre>"},{"location":"library/memory/#slicing-and-memoryviews","title":"Slicing and MemoryViews","text":"<p>Rmagine also provides mechanisms to slice these Memory objects and handling shallow copies through so-called Memory Views.</p> <pre><code>rm::Memory&lt;float, RAM&gt; mem(1000);\n// MemoryView to the elements [100: 200]\nrm::MemoryView&lt;float, RAM&gt; slice = mem(100, 200);\n// this sets slice[0] and mem[100] to 10\nslice[0] = 10.0;\n</code></pre> <p>With that it is possible to access existing memory very flexible:</p> <pre><code>rm::Memory&lt;int, rm::RAM&gt; mem(1000);\nrm::Memory&lt;int, rm::VRAM_CUDA&gt; mem_(1000);\n\n// copy [100:200] to [0:100]\nmem(0, 100) = mem(100, 200)\nmem_(0, 100) = mem_(100, 200)\n\n// or even transfer memory slice-wise\nmem_(0, 100) = mem(500, 600); // upload a slice\nmem(400, 500) = mem_(100, 200); // download a slice\n</code></pre>"},{"location":"library/memory/#application-example-1","title":"Application Example 1","text":"<p>for debuging purposes sometimes it is required to print a fetch a single element out of a GPU buffer. Here we just want to print the first element of a GPU memory object as follows:</p> <ol> <li>copy one element to CPU through</li> <li>print</li> </ol> <pre><code>rm::Memory&lt;int, rm::VRAM_CUDA&gt; mem_(1000);\n\n// download [0:1] to CPU\nrm::Memory&lt;int, rm::RAM&gt; one_elem_mem = mem_(0,1);\nstd::cout &lt;&lt; one_elem_mem[0] &lt;&lt; std::endl;\n</code></pre>"},{"location":"library/memory/#application-example-2","title":"Application Example 2","text":"<p>Oftentimes the GPU has a very limited amount of Memory. In Code this can be overcome using Rmagine's slices as follows:</p> <pre><code>// max available CPU mem: 1000\nrm::Memory&lt;int, RAM&gt; mem(1000);\n// max available GPU mem: 10\nrm::Memory&lt;int, VRAM_CUDA&gt; mem_(10);\n\n// i = [0, 10, 20, 30, ..., 990]\nfor(size_t i=0; i&lt;mem.size(); i += mem_.size())\n{\n    mem_ = mem(i, i + mem_.size());\n    // process algorithm on GPU\n}\n</code></pre>"},{"location":"library/memory/#cuda-isolated-library-creation","title":"Cuda Isolated Library Creation","text":"<p>In order to ship a library and its headers, each CUDA piece of code should be invisable after compilation. That means the shipped header should be free of code that can be only proccessed by the NVCC compiler. Exeptions for that are, if the library is clearly marked as to use with CUDA. The following example shows how to achieve that using <code>Memory</code> objects and the function <code>add</code> from above. In this example the <code>add</code>-function is further improved to handle slices.</p>"},{"location":"library/memory/#signatures-header_1","title":"Signatures (Header):","text":"<p>File: <code>add.h</code> <pre><code>rm::Memory&lt;float, rm::RAM&gt; add(\n    const rm::MemoryView&lt;float, rm::RAM&gt;&amp; a, \n    const rm::MemoryView&lt;float, rm::RAM&gt;&amp; b);\n\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; add(\n    const rm::MemoryView&lt;float, rm::VRAM_CUDA&gt;&amp; a, \n    const rm::MemoryView&lt;float, rm::VRAM_CUDA&gt;&amp; b);\n</code></pre></p> <p>File <code>add.cuh</code> <pre><code>rm::Memory&lt;float, rm::VRAM_CUDA&gt; add(\n    const rm::MemoryView&lt;float, rm::VRAM_CUDA&gt;&amp; a, \n    const rm::MemoryView&lt;float, rm::VRAM_CUDA&gt;&amp; b);\n</code></pre></p>"},{"location":"library/memory/#code","title":"Code","text":"<p>File <code>add.cpp</code></p> <pre><code>#include \"add.h\"\n\nrm::Memory&lt;float, rm::RAM&gt; add(\n    const rm::MemoryView&lt;float, rm::RAM&gt;&amp; a, \n    const rm::MemoryView&lt;float, rm::RAM&gt;&amp; b)\n{\n    rm::Memory&lt;float, rm::RAM&gt; c(a.size());\n    for(size_t i=0; i &lt; a.size(); i++)\n    {\n        c[i] = a[i] + b[i];\n    }\n    return c;\n}\n</code></pre> <p>File: <code>add.cu</code></p> <pre><code>#include \"add.cuh\"\n\n__global__\nvoid add_kernel(const float* a, const float* b, float* c, unsigned int N)\n{\n    const unsigned int id = blockIdx.x * blockDim.x + threadIdx.x;\n    if(id &lt; N)\n    {\n        c[id] = a[id] + b[id];\n    }\n}\n\nrm::Memory&lt;float, rm::VRAM_CUDA&gt; add(\n    const rm::MemoryView&lt;float, rm::VRAM_CUDA&gt;&amp; a, \n    const rm::MemoryView&lt;float, rm::VRAM_CUDA&gt;&amp; b)\n{\n    rm::Memory&lt;float, rm::VRAM_CUDA&gt; c(a.size());\n    add_kernel&lt;&lt;&lt;c.size(), 1&gt;&gt;&gt;(a.raw(), b.raw(), c.raw(), c.size());\n    return c;\n}\n</code></pre>"},{"location":"library/memory/#main-and-cmake","title":"Main and CMake","text":"<p>File: <code>Main.cpp</code></p> <pre><code>#include &lt;rmagine/types/Memory.hpp&gt;\n#include \"add.h\"\n#include &lt;rmagine/types/MemoryCuda.hpp&gt;\n#include \"add.cuh\"\n\nint main(int argc, char** argv)\n{\n    // CPU\n    rm::Memory&lt;float, rm::RAM&gt; vec1(100);\n    rm::Memory&lt;float, rm::RAM&gt; vec2(100);\n    auto vec3 = add(vec1, vec2);\n    auto vec3_slice = add(vec1(0, 10), vec2(10, 20));\n\n    // GPU\n    rm::Memory&lt;float, rm::RAM&gt; vec1_(100);\n    rm::Memory&lt;float, rm::RAM&gt; vec2_(100);\n    auto vec3_ = add(vec1_, vec2_);\n    auto vec3_slice_ = add(vec1_(0, 10), vec2_(10, 20));\n\n    return 0;\n}\n</code></pre> <p>File: <code>CMakeLists.txt</code></p> <pre><code># ...\n\nadd_library(my_add add.cpp)\ncuda_add_library(my_add_cuda add.cu)\n\nadd_executable(Main Main.cpp)\ntarget_link_libraries(Main\n    my_add\n    my_add_cuda\n)\n\n# ...\n</code></pre> <p>The Main.cpp and potential other code thus can be compiled with another compiler than the NVCC host compiler even though the CUDA code is executed internally.</p>"}]}